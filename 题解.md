



## 一. 数学题/递归

6 Z字形变换

7 整数反转

8 字符串转换整数

5453  所有蚂蚁掉下来的最后一刻

面试题 16.11 跳水板

121 买卖股票的最佳时机

17 电话号码的字母组合

48 旋转图像

29 两数相除

31 下一个排列

36 有效的数独

37 解树独

38 外观数列

696 计数二进制子串

93 复原IP地址

336 回文对

43 字符串相乘

201 数字范围按位与

459 重复的子字符串

491 递增子序列

39 组合总和

40 组合总和II

657 机器人能否返回原点

557 反转字符串中的单词III

剑指 Offer 20 表示数值的字符串

51 N皇后

988 从叶结点开始的最小字符串

60 第k个排列

5491 矩阵对角线元素的和

5492 分割字符串的方案数

5493 删除最短的子数组使剩余数组有序

5494 统计所有可行路径

## 二. 树/链表

2 两数相

21 合并两个有序链表

25 K个一组翻转链表

109 有序链表转换二叉搜索树

110 平衡二叉树

111 二叉树的最小深度

112 路径总和

113 路径总和 II

437 路径总和 III

257 二叉树的所有路径

114 二叉树展开为链表

100 相同的树

337 打家劫社II

1569 将子数组重新排序得到同一个二叉查找树的方案数

107 二叉树的层序遍历II

## 三. 动态规划

5 最长回文子串

5454 统计全1子矩阵

62 不同路径

63 不同路径II

64 最小路径和

97 交错字符串

980 不同路径III(to do)

53 最大子序和

面试题 17.13 恢复空格

122 买卖股票的最佳时机II

303 最佳买卖股票时机含冷冻期

174 地下城游戏

312 戳气球

1025 除数博弈

410 分割数组的最大值

LCP 13 寻宝

337 打家劫社II

647 回文子串

546 移除盒子

5500 乘积为正数的最长子数组长度

486 预测赢家

5494 统计所有可行路径

## 四. 双指针

19 删除链表的倒数第N个结点

1 二数之和

15 三数之和

18 四数之和

11 盛最多水的容器

26 删除排序数组中的重复项

27 移除元素

28 实现strStr()

30 串联所有单词的子串

## 五.  堆栈

739 每日温度

112 路径总和(to do)

122 买卖股票的最佳时机II

22 括号生成

104 二叉树的最大深度

## 六. 图

62 不同路径

63 不同路径II

980 不同路径III

130 被围绕的区域

133 克隆图

733 图像渲染

332 重新安排行程

841 钥匙和房间

5501 使陆地分离的最少天数

## 七. 分治

35 搜索插入位置

53 最大子序和

312 戳气球 

4 寻找两个正序数组的中位数

剑指offer 11 旋转数组的最小数字

33 搜索旋转排序数组

34 在排序数组中查找元素的第一个和最后一个位置

## 题解

### 739 每日温度

Input: [73, 74, 75, 71, 69, 72, 76, 73]

Output: [1, 1, 4, 2, 1, 1, 0, 0]

n: 温度列表长度

m: [30, 100]长度

方法一：暴力遍历

对每个i，向后遍历直到找到j使得T[i] < T[j]

时间复杂度：O(n^2)

空间复杂度：O(n)

```java
class Solution {
    public int[] dailyTemperatures(int[] T) {
        int length = T.length;
        int[] ans = new int[length];
        for (int i = 0; i < length; i++) {
            ans[i] = days(i, T);
        }
        return ans;
    }

    public int days(int i, int[] T) {
        int ans = 0;
        int j;
        for (j = i; j < T.length; j++) {
            if (T[j] > T[i]) {
                return ans;
            } else {
                ans++;
            }
        }
        if (j == T.length && T[T.length - 1] <= T[i]) {
            return 0;
        }
        return ans;
    }
}
```

方法二：暴力改进版

因为温度只在[30, 100] 之间，可以构建`next`数组维护每个温度第一次出现的下标。反向遍历T

时间复杂度：O(mn)

空间复杂度：O(n)



```java
class Solution {
    public int[] dailyTemperatures(int[] T) {
        int n = T.length;
        int m = 101;
        int inf = 30001;
        int[] next = new int[m];
        int[] ans = new int[n];
        for (int i=0; i<m; i++) {
            next[i] = inf;
        }
        for (int i=n-1; i>=0; i--) {
            int minIndex = inf;
            for (int j=T[i]+1; j<=100; j++) {
                if (next[j] < minIndex) {
                    minIndex = next[j];
                }
            }
            if (minIndex < inf) ans[i] = minIndex - i;
            next[T[i]] = i;
        }
        return ans;
    }
}
```

方法三：单调栈

```java
class Solution {
    public int[] dailyTemperatures(int[] T) {
        int n = T.length;
        int[] ans = new int[n];
        Deque<Integer> stack = new LinkedList<Integer>();
        for (int i=0; i<n; i++) {
            while (!stack.isEmpty() && T[stack.peek()] < T[i]) {
                ans[stack.peek()] = i - stack.peek();
                stack.pop();
            }
            stack.push(i);
        }
        return ans;
    }
}
```

时间复杂度：O(n)

空间复杂度：O(n)

### 15 三数之和

方法一：HashMap

先对`nums`排序，时间O(nlogn)

然后用一个HashMap存储(数字，数字出现的次数)。

用两次循环第一层循环i，第二层循环j，然后判断0-nums[i]-nums[j]是否在数组中。注意一些边界情况。

时间复杂度:O(n^2)

空间复杂度:O(n)

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        HashMap<Integer, Integer> numMap = new HashMap<>();
        int length = nums.length;
        Arrays.sort(nums);
        // put (number, number_appear_time) to hashMap
        for (int i=0; i<length; i++) {
            if (numMap.containsKey(nums[i])) {
                numMap.put(nums[i], numMap.get(nums[i]) + 1);
            } else {
                numMap.put(nums[i], 1);
            }
        }
        for (int i=0; i<length; i++) {
            if (nums[i] > 0) break;
            if (i > 0 && nums[i] == nums[i-1]) continue;
            int left = 0 - nums[i];
            for (int j=i+1; j<length; j++) {
                if (j > i+1 && nums[j] == nums[j-1]) continue;
                if (numMap.containsKey(left-nums[j])) {
                    if (left-nums[j] == nums[j] && numMap.get(left-nums[j]) == 1) continue;
                    if (left-nums[j] < nums[j]) continue;
                    if (left-nums[j] == nums[j] && nums[j] == 0 && numMap.get(0) == 2) continue;
                    List<Integer> subAns = new ArrayList<>();
                    subAns.add(nums[i]);
                    subAns.add(nums[j]);
                    subAns.add(left-nums[j]);
                    ans.add(subAns);
                }
            }
        }
        return ans;
    }
}
```

方法二：双指针

时间复杂度：O(n^2)

空间复杂度：O(n)

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        int length = nums.length;
        Arrays.sort(nums);
        for (int i=0; i<length; i++) {
            if (i > 0 && nums[i] == nums[i-1]) continue;
            int left = 0 - nums[i];
            int k = length - 1;
            for (int j=i+1; j<length; j++) {
                if (j > i+1 && nums[j] == nums[j-1]) continue;
                while (j < k && nums[j] + nums[k] > left) {
                    k--;
                }
                if (j >= k) break;
                if (nums[j] + nums[k] == left) {
                    List<Integer> sub_ans = new ArrayList<>();
                    sub_ans.add(nums[i]);
                    sub_ans.add(nums[j]);
                    sub_ans.add(nums[k]);
                    ans.add(sub_ans);
                }
            }
        }
        return ans;
    }
}
```

### 1 二数之和

方法一：hashMap

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] ans = new int[2];
        int length = nums.length;
        HashMap<Integer, Integer> num_pos_map = new HashMap<>();
        for (int i=0; i<length; i++) {
            num_pos_map.put(nums[i], i);
        }
        for (int i=0; i<length; i++) {
            int left = target - nums[i];
            if (num_pos_map.containsKey(left) && num_pos_map.get(left) != i) {
                ans[0] = i;
                ans[1] = num_pos_map.get(left);
            }
        }
        return ans;
    }
}
```

### 70 爬楼梯

方法一：递归+memoize

f(x) = f(x-1) + f(x-2)

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public int climbStairs(int n) {
        int[] mem = new int[n+1];
        return climbStairsMem(n, mem);
    }

    public int climbStairsMem(int n, int[] mem) {
        if (n <= 1) return 1;
        if (mem[n] != 0) return mem[n];
        mem[n] = climbStairsMem(n-1, mem) + climbStairsMem(n-2, mem);
        return mem[n];
    }
}
```

方法二：动态规划

时间复杂度：O(n)

空间复杂度：O(1)

```java
class Solution {
    public int climbStairs(int n) {
        int p = 1;
        int q = 1;
        int r = 0;
        for (int i=2; i<=n; i++) {
            r = p + q;
            p = q;
            q = r;
        }
        return r;
    }
}
```

方法三：矩阵快速幂

![image-20200613112643148](/Users/lovelyfrog/Library/Application Support/typora-user-images/image-20200613112643148.png)

时间复杂度：O(logn)

空间复杂度：O(1)

```java
public class Solution {
   public int climbStairs(int n) {
       int[][] q = {{1, 1}, {1, 0}};
       int[][] res = pow(q, n);
       return res[0][0];
   }
   public int[][] pow(int[][] a, int n) {
       int[][] ret = {{1, 0}, {0, 1}};
       while (n > 0) {
           if ((n & 1) == 1) {
               ret = multiply(ret, a);
           }
           n >>= 1;
           a = multiply(a, a);
       }
       return ret;
   }
   public int[][] multiply(int[][] a, int[][] b) {
       int[][] c = new int[2][2];
       for (int i = 0; i < 2; i++) {
           for (int j = 0; j < 2; j++) {
               c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];
           }
       }
       return c;
   }
}
```

### 1300 转变数组后最接近目标值的数组和

方法一：二分法

两种情况：第一种情况，如果ans取最小的`arr`值时，仍然大于target，则在0-arr[0]中进行二分查找。

第二种情况，在所有的`arr`值中二分查找，直到`left == right - 1`时，再进行arr[left]-arr[right]的二分查找

时间复杂度：O(nlogn)

空间复杂度：O(n)

```java
class Solution {
    public int findBestValue(int[] arr, int target) {
        Arrays.sort(arr);
        int[] prefix = new int[arr.length];
        for (int i = 1; i < arr.length; i++) {
            prefix[i] = prefix[i-1] + arr[i-1];
        }
        if (arr.length * arr[0] > target) {
            return last(arr, -1, 0, target, prefix);
        }
        return find(arr, 0, arr.length - 1, target, prefix);
    }
    public int find(int[] arr, int left, int right, int target, int[] prefix) {
        if (left == right - 1) {
            return last(arr, left, right, target, prefix);
        }
        int middle = (left + right) / 2;
        int sumSub = prefix[middle] + (arr.length - middle)*arr[middle];
        if (sumSub < target) {
            return find(arr, middle, right, target, prefix);
        } else if (sumSub > target) {
            return find(arr, left, middle, target, prefix);
        } else {
            return arr[middle];
        }
    }

    public int last(int[] arr, int left, int right, int target, int[] prefix) {
        int leftValue, rightValue, midValue, leftSum, rightSum, midSum;
        rightValue = arr[right];
        if (left == -1) {
            leftValue = 0;
            leftSum = 0;
        } else {
            leftValue = arr[left];
            leftSum = prefix[left] + (arr.length - left) * leftValue;
        }
        rightSum = prefix[right] + (arr.length - right) * rightValue;
        while (leftSum < target && rightSum > target) {
            if (leftValue == rightValue - 1) {
                if (target - leftSum <= rightSum - target) return leftValue;
                return rightValue;
            }
            midValue = (rightValue + leftValue) / 2;
            midSum = prefix[right] + (arr.length - right) * midValue;
            if (midSum < target) {
                leftSum = midSum;
                leftValue = midValue;
            } else if (midSum > target) {
                rightSum = midSum;
                rightValue = midValue;
            } else {
                return midValue;
            }
        }
        if (leftSum < target && rightSum <= target) return rightValue;
        if (leftSum >= target && rightSum > target) return leftValue;
        return 0;
    }
}
```

### 14 最长公共前缀

方法一：纵向比较

m: `strs` 个数, n: 最短字符串长度。

时间复杂度：O(mn)

空间复杂度：O(1)

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        StringBuffer ans = new StringBuffer();
        int index = 0;
        char c;
        if (strs.length == 0) return ans.toString();
        int minLength = strs[0].length();
        for (String str: strs) {
            if (str.length() < minLength) minLength = str.length();
        }
        while (index < minLength) {
            c = strs[0].charAt(index);
            for (String str: strs) {
                if (c != str.charAt(index)) {
                    return ans.toString();
                }
            }
            ans.append(c);
            index++;
        }
        return ans.toString();
    }
}
```

### 20 有效的括号

方法一：栈

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public boolean isValid(String s) {
        if (s == "") return true;
        Deque<Character> stack = new LinkedList<Character>();
        for (int i=0; i<s.length(); i++) {
            char c = s.charAt(i);
            if (c == '(' || c == '[' || c == '{') {
                stack.push(c);
                continue;
            }
            if (stack.isEmpty()) {
                return false;
            } else {
                if ((c == ')' && stack.peek() == '(') || (c == ']' && stack.peek() == '[') || (c == '}' && stack.peek() == '{') ) {
                    stack.pop();
                } else {
                    return false;
                }
            }
        }
        if (stack.isEmpty()) {
            return true;
        } else {
            return false;
        }
    }
}
```

### 23 合并K个排序链表

方法一：优先队列

合并k个排序链表，链表的最长长度为n

时间复杂度：O(kn*logk)

空间复杂度：O(k)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    static Comparator<ListNode> cNode = new Comparator<>() {
        public int compare(ListNode p1, ListNode p2) {
            return p1.val - p2.val;
        }
    };
    public ListNode mergeKLists(ListNode[] lists) {
        Queue<ListNode> queue = new PriorityQueue<ListNode>(cNode);
        ListNode ans = new ListNode(0);
        ans.next = null;
        ListNode sentry = ans;
        for (ListNode p: lists) {
            if (p != null) queue.add(p);
        }
        while (!queue.isEmpty()) {
            ListNode minQ = queue.poll(); 
            if (minQ.next != null) {
                queue.add(minQ.next);
                minQ.next = null;
            }
            ans.next = minQ;
            ans = ans.next;
        }
        return sentry.next;
    }
}
```

方法二：分治 **To be done**

### 44 通配符匹配

方法一：递归

超时了。。。

```java
class Solution {
    public boolean isMatch(String s, String p) {
        return isMatch(s, p, 0, 0);
    }

    public boolean isMatch(String s, String p, int iS, int iP) {
        if (iS == s.length()) {
            if (iP == p.length()) return true;
            if (p.charAt(iP) == '*') return isMatch(s, p, iS, iP+1);
            return false;
        }
        if (iP == p.length()) return false;
        if ((s.charAt(iS) == p.charAt(iP) && p.charAt(iP) != '*') || p.charAt(iP) == '?') return isMatch(s, p, iS+1, iP+1);
        if (p.charAt(iP) == '*') {
            if (iP == p.length() - 1) return true;
            while (iS < s.length()) {
                if (p.charAt(iP+1) == '*') return isMatch(s, p, iS, iP+1);
                if ((s.charAt(iS) == p.charAt(iP+1) || p.charAt(iP+1) == '?' ) && isMatch(s, p, iS+1, iP+2)) {
                    return true;
                }
                iS++;
            }
        }
        return false;
    }
}
```

方法二：动态规划

m 为 s的长度，n 为 p的长度，`dp[i]][j]`表示从s的第i个位置和从p的第j个位置匹配。

时间复杂度：O(mn)

空间复杂度：O(mn)

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length(), n = p.length();
        int[][] dp = new int[m+1][n+1];
        dp[m][n] = 1;
        for (int j = n-1; j >= 0; j--) {
            if (p.charAt(j) == '*') dp[m][j] = dp[m][j+1];
        }
        for (int i = m-1; i >= 0; i--) {
            for (int j = n-1; j >= 0; j--) {
                if ((s.charAt(i) == p.charAt(j) && p.charAt(j) != '*') || p.charAt(j) == '?') dp[i][j] = dp[i+1][j+1];
                if (p.charAt(j) == '*') {
                    if (j == n-1) dp[i][j] = 1;
                    dp[i][j] = Math.max(dp[i][j+1], dp[i+1][j]);
                }
            }
        }
        if (dp[0][0] == 1) return true;
        return false;
    }
}
```

### 297 二叉树的序列化与反序列化

方法一：BFS

节点数为n

时间复杂度：O(n)

空间复杂度：O(n)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuffer sb = new StringBuffer("[");
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            TreeNode tmp = queue.poll();
            if (tmp != null) {
                sb.append(String.valueOf(tmp.val));
                queue.offer(tmp.left);
                queue.offer(tmp.right);
            } else {
                sb.append("null");
            }
            if (!queue.isEmpty()) {
                sb.append(",");
            } else {
                sb.append("]");
            }
        }
        return sb.toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[] nodes = data.substring(1, data.length()-1).split(",");
        Queue<TreeNode> queue = new LinkedList<>();
        if (nodes[0].equals("null")) return null;
        TreeNode root = new TreeNode(Integer.parseInt(nodes[0]));
        queue.offer(root);
        TreeNode tmp;
        int index = 1;
        while (!queue.isEmpty()) {
            tmp = queue.poll();
            tmp.left = setNode(nodes[index++]);
            tmp.right = setNode(nodes[index++]);
            if (tmp.left != null) queue.offer(tmp.left);
            if (tmp.right != null) queue.offer(tmp.right);
        }
        return root;
    }

    public TreeNode setNode(String s) {
        if (s.equals("null")) return null;
        int value = Integer.parseInt(s);
        TreeNode tmp = new TreeNode(value);
        tmp.left = null;
        tmp.right = null;
        return tmp;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```

### 1014 最佳观光组合

方法一：`A[i] + i + A[j] - j `

[8, 1, 5, 2, 6] A

[0,1,2,3,4]

[8, 2, 7, 5, 10] A1

[8, 0, 3, -1, 2] A2

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public int maxScoreSightseeingPair(int[] A) {
        int[] A1 = new int[A.length];
        int[] A2 = new int[A.length];
        for (int i=0; i<A.length; i++) {
            A1[i] = A[i] + i;
            A2[i] = A[i] - i;
        }
        int max = A1[0];
        int maxSpot = 0;
        for (int j=1; j<A.length; j++) {
            if (A1[j-1] > max) max = A1[j-1];
            if (max + A2[j] > maxSpot) maxSpot = max + A2[j];
        }
        return maxSpot;
    }
}
```

### 1343 大小为K且平均值大于等于阈值的子数组数目

方法一：就是暴力枚举呗

时间复杂度：O(n)

空间复杂度：O(1)

```java
class Solution {
    public int numOfSubarrays(int[] arr, int k, int threshold) {
        int ans = 0;
        int sum = 0;
        int sumThres = k * threshold;
        for (int i=0; i<=arr.length-k; i++) {
            if (i == 0) {
                for (int j=i; j<i+k; j++) {
                    sum += arr[j];
                }
            } else {
                sum = sum - arr[i-1]+arr[i+k-1];
            }
            if (sum >= sumThres) ans++;
        }
        return ans;
    }
}
```

### 1028 从先序遍历还原二叉树

方法一：栈回溯

S长度n

时间复杂度：O(n)

空间复杂度：O(n)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode recoverFromPreorder(String S) {
        Deque<TreeNode> stack = new LinkedList<>();
        int pos = 0;
        while (pos < S.length()) {
            int level = 0;
            int number = 0;
            while (S.charAt(pos) == '-') {
                pos++;
                level++;
            }
            while (pos < S.length() && S.charAt(pos) != '-') {
                int tmp = S.charAt(pos) - '0';
                number = number * 10 + tmp;
                pos++;
            }
            TreeNode tmp = new TreeNode(number); 
            if (stack.size() == level) {
                if (!stack.isEmpty()) {
                    TreeNode prev = stack.peek();
                    prev.left = tmp;
                }
            } else {
                while (stack.size() > level) {
                    stack.pop();
                }
                TreeNode prev = stack.peek();
                prev.right = tmp;
            }
            stack.push(tmp);
        }
        while (stack.size() > 1) {
            stack.pop();
        }
        return stack.peek();        
    }
}
```

方法二：递归 **To do**

### 125 验证回文串

方法一：先将字符串化简，去掉无关字符，将大写字母变成小写字母，大写字母+32即变为小写字母，这里需要注意的是要强制类型转化。n = s.length()

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public boolean isPalindrome(String s) {
        String newS = simplyfy(s);
        int length = newS.length();
        if (length == 0) return true;
        for (int i = 0; i <= (length - 1) / 2; i++) {
            char a = newS.charAt(i);
            char b = newS.charAt(length - 1 - i);
            if (a != b) {
                return false;
            }
        }
        return true;
    }

    public String simplyfy(String s) {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if ( (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z')) {
                sb.append(c);
            } else if (c >= 'A' && c <= 'Z') {
                char newC = (char)(c + 32);
                sb.append(newC);
            }
        }
        return sb.toString();
    }
}
```

方法二：在原字符上使用双指针判断

时间复杂度：O(n)

空间复杂度：O(1)

```java
class Solution {
    public boolean isPalindrome(String s) {
        int length = s.length();
        int left = 0;
        int right = length - 1;
        while (left < right) {
            while (left < right && !isDigitOrLetter(s.charAt(left))) {
                left++;
            }
            while (left < right && !isDigitOrLetter(s.charAt(right))) {
                right--;
            }
            char leftC = reverse(s.charAt(left));
            char rightC = reverse(s.charAt(right));
            if (leftC != rightC) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }

    public boolean isDigitOrLetter(char c) {
        if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z' ) || (c >= 'A' && c <= 'Z')) {
            return true;
        } else {
            return false;
        }
    }
    public char reverse(char c) {
        if (c >= 'A' && c <= 'Z') return (char) (c + 32);
        return c;
    }
}
```

### 41 缺失的第一个正数

方法一：直接构造Hash表

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        // minInteger 为nums中不为一的最小正整数
        int minInteger = Integer.MIN_VALUE;
        int isExistOne = 0;
        HashMap<Integer, Integer> hash = new HashMap<>();
        for (int num: nums) {
            hash.put(num, 0);
            if (num > 0 && num < minInteger && num != 1) {
                minInteger = num;
            }
            if (num == 1) isExistOne = 1;
        }
        if (isExistOne == 0) {
            return 1;
        } else {
            int i = 2;
            while (hash.containsKey(i)) i++;
            return i;
        }
    }
}
```

方法二：构造hash

对一个长度为N的数组，其中没有出现的最小正整数只能在[1, N+1]中。于是我们可以构造hash表，因为正好数组长度为N，对数组遍历，假定当前遍历到的数为x，如果它在[1, N]中，则在数组的x-1处打上标记。遍历完数组中所有的数后，找到没有标记的最小位置i，i+1即为结果。若都打上标记，则返回N+1

时间复杂度：O(N)

空间复杂度：O(1)

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int N = nums.length;
        for (int i = 0; i < N; i++) {
            if (nums[i] <= 0) nums[i] = N + 1;
        }

        for (int i = 0; i < N; i++) {
            int num = Math.abs(nums[i]);
            if (num >= 1 && num <= N && nums[num - 1] > 0) nums[num - 1] = - nums[num - 1]; 
        }

        for (int i = 0; i < N; i++) {
            if (nums[i] > 0) return i + 1;
        }
        return N + 1;
    }
}
```

### 139 单词拆分

方法一：递归

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        return wordBreak(s, wordDict, 0);
    }

    public boolean wordBreak(String s, List<String> wordDict, int pos) {
        if (pos == s.length()) return true;
        for (String word: wordDict) {
            int wordLength = word.length();
            if (pos + wordLength > s.length()) continue;
            if (s.substring(pos, pos+wordLength).equals(word)) {
                if (wordBreak(s, wordDict, pos + wordLength)) return true;
            }
        }
        return false;
    }
}
```

方法二：动态规划

假设字符串长度为n,word个数为k

时间复杂度：O(kn)

空间复杂度：O(n)

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        int length = s.length();
        int[] dp = new int[length+1];
        dp[length] = 1;
        for (int i = length-1; i >=0; i--) {
            for (String word: wordDict) {
                if (i + word.length() > length) continue;
                if (s.substring(i, i+word.length()).equals(word)) {
                    if (dp[i+word.length()] == 1) {
                        dp[i] = dp[i+word.length()];
                        break;
                    }
                }
            }
        }
        if (dp[0] == 1) {
            return true;
        } else {
            return false;
        }
    }
}
```

### 16 最接近的三数和

方法一：双指针

时间复杂度：O(n^2)

空间复杂度：O(1)

```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        int length = nums.length;
        Arrays.sort(nums);
        int inf = 1000;
        int leftMostClose = -3 * inf;
        int rightMostClose = 3 * inf;
        for (int i = 0; i < length; i++) {
            int k = length - 1;
            for (int j = i + 1; j < length; j++) {
                if (j > i+1 && nums[j] == nums[j-1]) continue;
                while (j < k && nums[i] + nums[j] + nums[k] > target) {
                    if (nums[i] + nums[j] + nums[k] < rightMostClose) {
                        rightMostClose = nums[i] + nums[j] + nums[k];
                    }
                    k--;
                }
                if (j >= k) break;
                if (nums[i] + nums[j] + nums[k] >= leftMostClose)
                    leftMostClose = nums[i] + nums[j] + nums[k];
            }
        }
        if (target - leftMostClose > rightMostClose - target) {
            return rightMostClose;
        } else {
            return leftMostClose;
        }
    }
}
```

### 67 二进制求和

方法一：暴力

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public String addBinary(String a, String b) {
        int lengthA = a.length();
        int lengthB = b.length();
        int i = lengthA - 1, j = lengthB - 1, prev = 0;
        StringBuffer sb = new StringBuffer("");
        while (i >= 0 || j >= 0) {
            int A, B;
            if (i >= 0) {
                A = a.charAt(i) - '0';
            } else {
                A = 0;
            }
            if (j >= 0) {
                B = b.charAt(j) - '0';
            } else {
                B = 0;
            }
            if (A + B + prev == 0) {
                prev = 0;
                sb.append('0');
            } else if(A + B + prev == 1) {
                prev = 0;
                sb.append('1');
            } else if(A + B + prev == 2) {
                prev = 1;
                sb.append('0');
            } else if(A + B + prev == 3) {
                prev = 1;
                sb.append('1');
            }
            i--;
            j--;
        }
        if (prev == 1) sb.append('1');
        return sb.reverse().toString();
    }
}
```

### 124 二叉树中的最大路径

方法一：递归 maxGain(node) 指的是从node出发到node子结点路径和的最大距离。

时间复杂度：O(N)

空间复杂度：O(N)

```java
class Solution {
    int maximum = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        maxGain(root);
        return maximum;
    }
    public int maxGain(TreeNode node) {
        if (node == null) return 0;
        int leftMaxGain = Math.max(maxGain(node.left), 0);
        int rightMaxGain = Math.max(maxGain(node.right), 0);
        int middleMax = leftMaxGain + rightMaxGain + node.val;
        if (middleMax > maximum) maximum = middleMax;
        return (leftMaxGain + node.val > rightMaxGain + node.val)? leftMaxGain + node.val: rightMaxGain + node.val;
    }
}
```

 ### 209 长度最小的子数组

方法一：双指针

时间复杂度：O(n)

空间复杂度：O(1)

```java
class Solution {
    public int minSubArrayLen(int s, int[] nums) {
        if (nums.length == 0) return 0;
        int inf = Integer.MAX_VALUE;
        int minLength = inf;
        int left = 0, right = 0;
        int sumSub = nums[left];
        while (left <= right) {
            while (sumSub < s && right < nums.length - 1) {
                right++;
                sumSub += nums[right];
            }
            if (sumSub >= s && minLength >= right - left + 1) {
                minLength = right - left + 1;
            }
            sumSub = sumSub - nums[left];
            left++;
        }
        return (minLength == inf)?0: minLength;
    }
}
```

### 112 路径总和

方法一：递归

时间复杂度：O(N)

空间复杂度：O(N)

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) return false;
        if (root.val == sum && root.left == null && root.right == null) return true;
        if (hasPathSum(root.left, sum - root.val)) {
            return true;
        } else if (hasPathSum(root.right, sum - root.val)) {
            return true;
        } else {
            return false;
        }
    }
}
```

方法二：利用队列BFS

建立两个队列，一个队列保存的是当前节点，另一个队列保存的是当前节点的节点和

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) return false;
        Deque<TreeNode> nodeQueue = new LinkedList<>();
        Deque<Integer> sumQueue = new LinkedList<>();
        nodeQueue.push(root);
        sumQueue.push(root.val);
        while (!nodeQueue.isEmpty()) {
            TreeNode tmpNode = nodeQueue.pop();
            int tmpSum = sumQueue.pop();
            if (tmpSum == sum && tmpNode.left == null && tmpNode.right == null) return true;
            if (tmpNode.left != null) {
                nodeQueue.push(tmpNode.left);
                sumQueue.push(tmpSum + tmpNode.left.val);
            }
            if (tmpNode.right != null) {
                nodeQueue.push(tmpNode.right);
                sumQueue.push(tmpSum + tmpNode.right.val);
            }
        }
        return false;
    }
}
```





### 10 正则表达式匹配

方法一：动态规划

`dp[i][j]`表示从s的第i个位置和从p的第j个位置匹配。



```java
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length();
        int n = p.length();
        int[][] dp = new int[m+1][n+1];
        dp[m][n] = 1;	//两个字符串最后一位再向后一位，置为0。
        for (int j = n-1 ; j >= 0; j--) {
            if (j < n-1 && p.charAt(j+1) == '*') {
                dp[m][j] = dp[m][j+2];
            }
        }
        for (int i = m-1; i >= 0; i--) {
            for (int j = n-1; j >= 0; j--) {
                if (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.') {
                    if (j < n - 1 && p.charAt(j+1) == '*') {
                        dp[i][j] = Math.max(dp[i+1][j], dp[i][j+2]);
                    } else {
                        dp[i][j] = dp[i+1][j+1];
                    }

                } else if(s.charAt(i) != p.charAt(j)) {
                    if (j < n - 1 && p.charAt(j+1) == '*')
                        dp[i][j] = dp[i][j+2];
                }
            }
        }
        return (dp[0][0] == 1)?true:false;
    }
}
```

### 215 数组中的第K个最大元素

方法一：作弊

直接调用`Arrays.sort()`

时间复杂度：O(n logn)

空间复杂度：O(1)

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        Arrays.sort(nums);
        return nums[nums.length - k];
    }
}
```

方法二：quickselect，根据quick sort改的。

时间复杂度：O(n)

空间复杂度：O(1)

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        return quickSelect(nums, k, 0, nums.length - 1);
    }
    // 找到nums中从start到end下标中第k大的元素
    public int quickSelect(int[] nums, int k, int start, int end) {
        if (start == end) return nums[start];
      	// 加个random速度提升很多
        int r = start+(int)(Math.random()*(end+1-start));
        swap(nums, start, r);
        int pivot = nums[start];
        int L = start + 1;
        int G = end;
        while (L <= G) {
            while (L <= end && nums[L] <= pivot) {
                L++;
            }
            while (G > start && nums[G] >= pivot) {
                G--;
            }
            if (L < G) {
                swap(nums, L, G);
              	L++;
              	G--;
            }
        }
        swap(nums, start, G);
        int pivotK = end - G + 1;   //pivot在 start-end 中第几大的位置
        if (pivotK < k) {
            return quickSelect(nums, k - pivotK, start, G - 1);
        } else if (end - G + 1 > k) {
            return quickSelect(nums, k, G + 1, end);
        } else {
            return pivot;
        }
    }
    public void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```

### 剑指offer 09. 用两个栈实现队列

方法一：维护两个栈，将增加的新元素放入stack1的栈顶。删除元素时，先看stack2中是否有元素，如果有的话，删除stack2的栈顶元素，如果没有，判断stack1是否为空，若为空则返回-1，若不为空将stack1的元素全部推入stack2中。

时间复杂度：O(n)

空间复杂度：O(n)

```java
class CQueue {
    Deque<Integer> stack1;
    Deque<Integer> stack2;
    public CQueue() {
        stack1 = new LinkedList<>();
        stack2 = new LinkedList<>();
    }
    
    public void appendTail(int value) {
        stack1.push(value);
    }
    
    public int deleteHead() {
        if (!stack2.isEmpty()) {
            return stack2.pop();
        } else {
            if (stack1.isEmpty()) return -1;
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
            return stack2.pop();
        }
    }
}

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue obj = new CQueue();
 * obj.appendTail(value);
 * int param_2 = obj.deleteHead();
 */
```

### 94 二叉树的中序遍历

方法一：递归

时间复杂度：O(n)

空间复杂度：O(n)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    List<Integer> ans = new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        inorder(root);
        return ans;
    }
    public void inorder(TreeNode node) {
        if (node == null) return;
        inorder(node.left);
        ans.add(node.val);
        inorder(node.right);
    }
}
```

方法二：迭代

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        Deque<TreeNode> stack = new LinkedList<>();
        TreeNode node = root;
        while (node != null) {
            stack.push(node);
            node = node.left;
        }
        while (!stack.isEmpty()) {
            node = stack.pop();
            ans.add(node.val);
            node = node.right;
            while (node != null) {
                stack.push(node);
                node = node.left;
            }
        }
        return ans;
    }
}
```

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        Deque<TreeNode> stack = new LinkedList<>();
        TreeNode node = root;
        while (node != null || !stack.isEmpty()) {
            while (node != null) {
                stack.push(node);
                node = node.left;
            }
            node = stack.pop();
            ans.add(node.val);
            node = node.right;
        }
        return ans;
    }
}
```



### 96 不同的二叉搜索树

方法一：动态规划。

`dp[i]`表示当n取i时，二叉搜索树的个数。

`[1, 2, ... i, ... n]` ，当取n的时候，可以先令1...n每个数当根结点。当取i为根结点时，i左边为左子树，i右边的数为右子树。于是我们可以得到
$$
dp[n] = \sum_{j = 1}^n dp[j-1] \cdot dp[n-j]
$$


时间复杂度：O(n^2)

空间复杂度：O(n)

```java
class Solution {
    public int numTrees(int n) {
        int[] dp =  new int[n+1];
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] = dp[i] + dp[j-1]*dp[i-j];
            }
        }
        return dp[n];
    }
}
```

### 95 不同的二叉搜索树II

方法一：递归



```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<TreeNode> generateTrees(int n) {
        if (n == 0) return new ArrayList<TreeNode>();
        return generateTrees(1, n);
    }
    public List<TreeNode> generateTrees(int start, int end) {
        List<TreeNode> ans = new ArrayList<>();
        if (start > end) {
            ans.add(null);
            return ans;
        }
        for (int i = start; i <= end; i++) {
            List<TreeNode> left = generateTrees(start, i-1);
            List<TreeNode> right = generateTrees(i+1, end);
            for (int m = 0; m < left.size(); m++) {
                for (int n = 0; n < right.size(); n++) {
                    TreeNode curr = new TreeNode(i, left.get(m), right.get(n));
                    ans.add(curr);
                }
            }
        }
        return ans;
    }
}
```

### 98 验证二叉搜索树

方法一：递归

假定当前结点`curr`在`(min, max)`的范围之间，那么它的左子结点应该在`(min, curr.val)`之间，右子结点应该在`(curr.val, max)`之间

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        return helper(root, null, null);
    }
    public boolean helper(TreeNode curr, Integer min, Integer max) {
        if (curr == null) return true;
        if (curr.val <= min || curr.val >= max) return false;
        boolean leftValid = helper(curr.left, min, curr.val);
        if (!leftValid) return false;
        boolean rightValid = helper(curr.right, curr.val, max);
        if (!rightValid) return false;
        return true;
    }
}
```

方法二：中序遍历(递归)，当然也可以迭代。

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        Deque<Integer> stack = new LinkedList<>();
        return inOrder(root, stack);
    }
    public boolean inOrder(TreeNode curr, Deque<Integer> stack) {
        if (curr == null) return true;
        if (!inOrder(curr.left, stack)) return false;
        if (!stack.isEmpty() && curr.val <= stack.peek()) return false;
        stack.push(curr.val);
        if (!inOrder(curr.right, stack)) return false;
        return true;
    }
}
```

### 718 最长重复子数组

方法一：动态规划

`dp[i][j]`表示A中第i个位置开始，B中第j个位置开始的最长公共前缀长度。

时间复杂度：O(n*m)

空间复杂度：O(n*m)


```java
class Solution {
    public int findLength(int[] A, int[] B) {
        int m = A.length;
        int n = B.length;
        int[][] dp = new int[m+1][n+1];
        int maxSubLength = 0;
        for (int i = m-1; i >= 0; i--) {
            for (int j = n-1; j >= 0; j--) {
                if (A[i] != B[j]) {
                    dp[i][j] = 0;
                }else {
                    dp[i][j] = 1 + dp[i+1][j+1];
                }
                if (dp[i][j] > maxSubLength) maxSubLength = dp[i][j];
            }
        }
        return maxSubLength;
    }
}
```

方法二：滑动窗口

### 583 两个字符串的删除操作

方法一：动态规划

时间复杂度：O(n^2)

空间复杂度：O(n^2)

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        if (m == 0 || n == 0) return Math.max(m, n);
        int[][] dp = new int[m+1][n+1];
        for (int i = n-1; i >= 0; i--) {
            dp[m][i] = n - i;
        }
        for (int i = m-1; i >= 0; i--) {
            dp[i][n] = m - i;
        }
        for (int i = m-1; i >= 0; i--) {
            for (int j = n-1; j >= 0; j--) {
                if (word1.charAt(i) == word2.charAt(j)) {
                    dp[i][j] = dp[i+1][j+1];
                } else {
                    dp[i][j] = 1 + Math.min(dp[i+1][j], dp[i][j+1]);
                }
            }
        }
        return dp[0][0];
    }
}
```

### 378 有序矩阵中第k小的元素

方法一：归并排序

构造优先队列，先将第一行所有数入列。然后抛出最小值，将当前最小值的同一列的后一行入列，直至第k个数抛出。

时间复杂度：O(k logn)

空间复杂度：O(n)

```java
class Solution {
    class node {
        int i;
        int j;
        int val;
        node(int i, int j, int val) {this.i = i; this.j = j; this.val = val;}
    }
    static Comparator<node> cNode = new Comparator<>() {
        public int compare(node p1, node p2) {
            return p1.val - p2.val;
        }
    };
    public int kthSmallest(int[][] matrix, int k) {
        int m = matrix.length;
        int n = matrix[0].length;
        Queue<node> queue = new PriorityQueue<>(cNode);
        int cnt = 0, ans = 0;
        for (int j = 0; j < n; j++) {
            queue.add(new node(0, j, matrix[0][j]));
        }
        while (!queue.isEmpty()) {
            node minQ = queue.poll();
            cnt++;
            if (cnt == k) {
                ans = minQ.val;
                break;
            }
            if (minQ.i < m - 1) {
                queue.add(new node(minQ.i+1, minQ.j, matrix[minQ.i+1][minQ.j]));
            }
        } 
        return ans;
    }
}
```

```java
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                return a[0] - b[0];
            }
        });
        int n = matrix.length;
        for (int i = 0; i < n; i++) {
            pq.offer(new int[]{matrix[i][0], i, 0});
        }
        for (int i = 0; i < k - 1; i++) {
            int[] now = pq.poll();
            if (now[2] != n - 1) {
                pq.offer(new int[]{matrix[now[1]][now[2] + 1], now[1], now[2] + 1});
            }
        }
        return pq.poll()[0];
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/solution/you-xu-ju-zhen-zhong-di-kxiao-de-yuan-su-by-leetco/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### 108 将有序数组转换为二叉搜索树

方法一：二分法递归

时间复杂度：O(n)

空间复杂度：O(log n)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        int length = nums.length;
        return sortedArrayToBST(nums, 0, length - 1);
    }
    public TreeNode sortedArrayToBST(int[] nums, int left, int right) {
        if (left == right) return new TreeNode(nums[left]);
        if (left > right) return null;
        int mid = (left + right) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = sortedArrayToBST(nums, left, mid - 1);
        root.right = sortedArrayToBST(nums, mid + 1, right);
        return root;
    }
}
```

### 32 最长有效括号

方法一：栈，栈中放的是下标

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public int longestValidParentheses(String s) {
        Deque<Integer> stack = new LinkedList<>();
        int length = s.length();
        int ans = 0;
        stack.push(-1);
        for (int i = 0; i < length; i++) {
            char tmp = s.charAt(i);
            if (tmp == '(') {
                stack.push(i);
            } else if (tmp == ')') {
                stack.pop();
                if (stack.isEmpty()) {
                    stack.push(i);
                }else {
                    ans = Math.max(ans, i - stack.peek());
                }
            }
        }
        return ans;
    }
}
```

方法二：动态规划

令`dp[i]`表示以第i个字符开头的，最长有效括号长度

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public int longestValidParentheses(String s) {
        int m = s.length();
        int[] dp = new int[m+1];
        int ans = 0;
        for (int i = m - 2; i >= 0; i--) {
            if (s.charAt(i) == '(') {
                if (s.charAt(i+1) == ')') {
                    dp[i] = dp[i+2] + 2;
                } else {
                    if (i + dp[i+1] + 1 < m && s.charAt(i + dp[i+1] + 1) == ')')
                        dp[i] = dp[i+1] + dp[i + dp[i+1] + 2] + 2;
                }
                ans = Math.max(ans, dp[i]);
            }
        }
        return ans;
    }
}
```

### 5454 统计全1子矩阵

方法一：动态规划

时间复杂度：O(nmm)

空间复杂度：O(mn)

`dp[i][j]`表示的是i行第j个位置的最多连续1个数。先遍历所有位置，得到`dp`。然后进行第二次遍历，对于每个位置(i, j)，因为(i, j)的出现会使得第i,i-1,..0这些层出现新的子矩阵。

```java
class Solution {
    public int numSubmat(int[][] mat) {
        int m = mat.length;
        int n = mat[0].length;
        int[][] dp = new int[m][n];
        int ans = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (mat[i][j] == 1) { 
                    dp[i][j] = (j == 0)?1:dp[i][j-1] + 1;
                }
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int tmp = dp[i][j];
                for (int k = i; k >= 0; k--) {
                    tmp = Math.min(dp[k][j], tmp);
                    ans += tmp;
                }
            }
        }
        return ans;
    }
}
```

### 5453 所有蚂蚁掉下来的最后一刻

方法一：没啥方法，就一智力题，蚂蚁碰撞可以想成蚂蚁穿透。

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public int getLastMoment(int n, int[] left, int[] right) {
        int ans = 0;
        for (int i = 0; i < left.length; i++) {
            ans = Math.max(ans, left[i]);
        }
        for (int i = 0; i < right.length; i++) {
            ans = Math.max(ans, n - right[i]);
        }
        return ans;
    }
}
```

### 63 不同路径II

方法一：DFS

超时！

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if (obstacleGrid[0][0] == 0)
            return dfs(obstacleGrid, 0, 0);
        return 0;
    }
    public int dfs(int[][] obstacleGrid, int i, int j) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        if (i == m - 1 && j == n - 1){
            return (obstacleGrid[i][j] == 1)?0:1;
        }
        int ans = 0;
        if (j + 1 < n && obstacleGrid[i][j+1] != 1) {
            ans += dfs(obstacleGrid, i, j+1);
        }
        if (i + 1 <m && obstacleGrid[i+1][j] != 1) {
            ans += dfs(obstacleGrid, i+1, j);
        }
        return ans;
    }
}
```

方法二：加了memoized 的DFS

时间复杂度：O(mn)

空间复杂度：O(mn)

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        int[][] mem = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                mem[i][j] = -1;
            }
        }
        if (obstacleGrid[0][0] == 0)
            return dfs(obstacleGrid, 0, 0, mem, m, n);
        return 0;
    }
    public int dfs(int[][] obstacleGrid, int i, int j, int[][] mem, int m, int n) {
        if (i == m - 1 && j == n - 1){
            return (obstacleGrid[i][j] == 1)?0:1;
        }
        if (mem[i][j] != -1) return mem[i][j];
        mem[i][j] = 0;
        if (j + 1 < n && obstacleGrid[i][j+1] != 1) {
            mem[i][j] += dfs(obstacleGrid, i, j+1, mem, m, n);
        }
        if (i + 1 <m && obstacleGrid[i+1][j] != 1) {
            mem[i][j] += dfs(obstacleGrid, i+1, j, mem, m, n);
        }
        return mem[i][j];
    }
}
```

方法三：动态规划

时间复杂度：O(mn)

空间复杂度：O(mn)

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        int[][] dp = new int[m][n];
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                if (i == m - 1 && j == n - 1) {
                    dp[i][j] = (obstacleGrid[i][j] == 0)?1:0;
                } else if (obstacleGrid[i][j] == 1){
                    dp[i][j] = 0;
                } else {
                    if (j + 1 < n) dp[i][j] += dp[i][j+1];
                    if (i + 1 < m) dp[i][j] += dp[i+1][j];
                }
            }
        }
        return dp[0][0];
    }
}
```

### 62 不同路径

方法一：动态规划

时间复杂度：O(mn)

空间复杂度：O(mn)

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[n][m];
        for (int i = n - 1; i >= 0; i--) {
            for (int j = m - 1; j >= 0; j--) {
                if (i == n - 1 && j == m - 1){
                     dp[i][j] = 1;
                } else {
                    if (j + 1 < m) dp[i][j] += dp[i][j+1];
                    if (i + 1 < n) dp[i][j] += dp[i+1][j];
                }
            }
        }
        return dp[0][0];
    }
}
```

改进版：空间复杂度：O(m)

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[2][m];
        for (int i = n - 1; i >= 0; i--) {
            for (int j = m - 1; j >= 0; j--) {
                int a = i % 2;
                int b = 1 - a;
                dp[a][j] = 0;
                if (i == n - 1 && j == m - 1){
                     dp[a][j] = 1;
                } else {
                    if (j + 1 < m) dp[a][j] += dp[a][j+1];
                    if (i + 1 < n) dp[a][j] += dp[b][j];
                }
            }
        }
        return dp[0][0];
    }
}
```

### 980 不同路径III

方法一：DFS

遍历每一个0方格，并置其为已访问。回溯的时候要将其置为未访问。

时间复杂度：$O(4^{mn})$

空间复杂度：O(mn)

```java
class Solution {
    public int uniquePathsIII(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int [][] isVisited = new int[m][n];
        int startI = 0, startJ = 0;
        int zeroNum = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    startI = i;
                    startJ = j;
                }
                if (grid[i][j] == 0) zeroNum++;
            }
        }
        return dfs(grid, isVisited, startI, startJ, m, n, zeroNum, startI, startJ);
    }
    public int dfs(int[][] grid, int[][] isVisited, int i, int j, int m, int n, int zeroNum, int startI, int startJ) {
        isVisited[i][j] = 1;
        if (grid[i][j] == 2 && zeroNum == 0) {
            isVisited[i][j] = 0;
            return 1;
        }
        int ans = 0;
        if (i == startI && j == startJ) {
        } else {
            zeroNum--;
        }
        if (i - 1 >= 0 && (grid[i-1][j] == 0 || grid[i-1][j] == 2) && isVisited[i-1][j] == 0) {
            ans += dfs(grid, isVisited, i-1, j, m, n, zeroNum, startI, startJ);
            isVisited[i-1][j] = 0;
        }
        if (i + 1 < m && (grid[i+1][j] == 0 || grid[i+1][j] == 2) && isVisited[i+1][j] == 0) {
            ans += dfs(grid, isVisited, i+1, j, m, n, zeroNum, startI, startJ);
            isVisited[i+1][j] = 0;
        }
        if (j - 1 >= 0 && (grid[i][j-1] == 0 || grid[i][j-1] == 2) && isVisited[i][j-1] == 0) {
            ans += dfs(grid, isVisited, i, j-1, m, n, zeroNum, startI, startJ);
            isVisited[i][j-1] = 0;
        }
        if (j + 1 < n && (grid[i][j+1] == 0 || grid[i][j+1] == 2) && isVisited[i][j+1] == 0) {
            ans += dfs(grid, isVisited, i, j+1, m, n, zeroNum, startI, startJ);
            isVisited[i][j+1] = 0;
        }
        isVisited[i][j] = 0;
        zeroNum++;
        return ans;
    }
}
```
简洁版

```java
class Solution {
    int[][] grid;
    int m, n;
    int startI = 0, startJ = 0;
    int zeroNum = 0;
    int[][] isVisited;
    int[] dr = new int[]{-1, 1, 0, 0};
    int[] dc = new int[]{0, 0, -1, 1};
    public int uniquePathsIII(int[][] grid) {
        this.m = grid.length;
        this.n = grid[0].length;
        this.grid = grid;
        this.isVisited = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    this.startI = i;
                    this.startJ = j;
                }
                if (grid[i][j] == 0) this.zeroNum++;
            }
        }
        return dfs(startI, startJ);
    }
    public int dfs(int i, int j) {
        this.isVisited[i][j] = 1;
        if (this.grid[i][j] == 2 && this.zeroNum == 0) {
            this.isVisited[i][j] = 0;
            return 1;
        }
        int ans = 0;
        if (i == this.startI && j == this.startJ) {
        } else {
            this.zeroNum--;
        }
        int nextI, nextJ;
        for (int k = 0; k < 4; k++) {
            nextI = i + this.dr[k];
            nextJ = j + this.dc[k];
            if (nextI >= 0 && nextI < this.m && nextJ >=0 && nextJ < this.n && this.isVisited[nextI][nextJ] == 0) {
                if (this.grid[nextI][nextJ] == 0 || this.grid[nextI][nextJ] == 2) {
                    ans += dfs(nextI, nextJ);
                }
            }
        }
        this.isVisited[i][j] = 0;
        this.zeroNum++;
        return ans;
    }
}
```

方法二：动态规划(to do)

### 面试题 16.11 跳水板

方法一：数学

时间复杂度：O(n)

空间复杂度：O(1)

```java
class Solution {
    public int[] divingBoard(int shorter, int longer, int k) {
        if (k == 0) return new int[0];
        int sum = shorter * k;
        if (shorter == longer) return new int[]{sum};
        int[] ans = new int[k+1];
        for (int i = 0; i < k + 1; i++) {
            ans[i] = sum - i * shorter + i * longer;
        }
        return ans;
    }
}
```

### 面试题 17.13 恢复空格

方法一：动态规划+hash

将字符串保存在hash表中

`dp[i]`表示第i位置的字符前（不包含）的未识别的字符数，假设词典里面有n个字符串

时间复杂度：O(m^2 + |dictionary|)

空间复杂度：O(m + n)

```java
class Solution {
    public int respace(String[] dictionary, String sentence) {
        int m = sentence.length();
        int[] dp = new int[m+1];
        HashMap<String, Integer> hash = new HashMap<>();
        for (String tmp: dictionary) {
            hash.put(tmp, 0);
        }
        for (int i = 1; i <= m; i++) {
            dp[i] = 1000;
            for (int j = i; j >= 0; j--) {
                if (hash.containsKey(sentence.substring(j, i))) {
                    dp[i] = Math.min(dp[i], dp[j]);
                } else {
                    dp[i] = Math.min(dp[i], dp[j]+i-j);
                }
            }
        } 
        return dp[m];
    }
}
```

方法二：动态规划+trie

trie树中构造的是字符串的倒序。

时间复杂度：O(m^2 + |dictionary|)

空间复杂度：O(26 * |dictionary| + n)

```java
class Solution {
    class Trie {
        int isWord;
        Trie[] alphabet; 
        public Trie() {
            this.isWord = 0;
            this.alphabet = new Trie[26];
        }
        public void insert(String str){
            Trie node = this;
            int n = str.length();
            for (int i = n-1; i >= 0; i--) {
                int c = (int)str.charAt(i) - 'a';
                if (node.alphabet[c] == null) node.alphabet[c] = new Trie();
                node = node.alphabet[c];
            }
            node.isWord = 1;
        }
    }
    public int respace(String[] dictionary, String sentence) {
        int m = sentence.length();
        int[] dp = new int[m+1];
        Trie root = new Trie();
        for (String str: dictionary) {
            root.insert(str);
        }
        for (int i = 1; i <= m; i++) {
            dp[i] = dp[i-1] + 1;
            Trie tmp = root;
            for (int j = i - 1; j >= 0; j--) {
                int c = (int)sentence.charAt(j) - 'a';
                if (tmp.alphabet[c] == null) {
                    break;
                } else if (tmp.alphabet[c].isWord == 1){
                    dp[i] = Math.min(dp[i], dp[j]);
                }
                tmp = tmp.alphabet[c];
            }
        } 
        return dp[m];
    }
}
```

### 303 最佳买卖股票时机含冷冻期

方法一：动态规划

`dp[i][0]`表示在第i天持有股票的情况下最大收益

`dp[i][1]`表示在第i天不持有股票，处于冷冻期的最大收益

`dp[i][2]`表示在第i天不持有股票且不是冷冻期的最大收益

时间复杂度：O(n)

空间复杂度：O(n)，优化空间后为O(1)

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        if (n == 0) return 0;
        int[][] dp = new int[n][3];
        dp[0][0] = -prices[0];
        for (int i = 1; i < n; i++) {
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][2]-prices[i]);
            dp[i][1] = dp[i-1][0] + prices[i];
            dp[i][2] = Math.max(dp[i-1][1], dp[i-1][2]);
        }
        int tmpMax = Math.max(dp[n-1][1], dp[n-1][2]);
        return Math.max(tmpMax, dp[n-1][0]);
    }
}
```

优化空间：

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        if (n == 0) return 0;
        int[] prev = new int[3];
        int[] next = new int[3];
        prev[0] = -prices[0];
        for (int i = 1; i < n; i++) {
            next[0] = Math.max(prev[0], prev[2]-prices[i]);
            next[1] = prev[0] + prices[i];
            next[2] = Math.max(prev[1], prev[2]);
            prev[0] = next[0];
            prev[1] = next[1];
            prev[2] = next[2];
        }
        return Math.max(prev[1], prev[2]);
    }
}
```

### 121 买卖股票的最佳时机

方法一：一次遍历

在第i位置，记录前i的最小值index，然后判断是更新当前最小值还是更新an

时间复杂度：O(n)

空间复杂度：O(1)

```java
class Solution {
    public int maxProfit(int[] prices) {
        int minIndex = 0;
        int n = prices.length;
        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (prices[i] < prices[minIndex]) {
                minIndex = i;
            } else {
                ans = Math.max(ans, prices[i] - prices[minIndex]);
            }
        }
        return ans;
    }
}
```



### 350 两个数组的交集

方法一：先排序

令num1和num2中比较长的数组长度为n

时间复杂度：O(nlogn)

空间复杂度：O(n)

```java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int nums1Length = nums1.length;
        int nums2Length = nums2.length;
        int i = 0, j = 0;
        List<Integer> ans = new ArrayList<>();
        while (i < nums1Length && j < nums2Length) {
            if (nums1[i] == nums2[j]) {
                ans.add(nums1[i]);
                i++;
                j++;
            } else if (nums1[i] > nums2[j]) {
                j++;
            } else {
                i++;
            }
        }
        int[] finalAns = new int[ans.size()];
        for (i = 0; i < ans.size(); i++) {
            finalAns[i] = ans.get(i);
        } 
        return finalAns;
    }
}
```

方法二：hash表

时间复杂度：O(n)

空间复杂度：O(n)

### 174 地下城游戏

方法一：动态规划

`dp[i][j]`表示从(i,j)到终点所需的最低初始健康点数

时间复杂度：O(mn)

空间复杂度：O(mn)

```java
class Solution {
    public int calculateMinimumHP(int[][] dungeon) {
        int m = dungeon.length;
        int n = dungeon[0].length;
        int[][] dp = new int[m][n];
        dp[m-1][n-1] = Math.max(-dungeon[m-1][n-1]+1, 1);
        for (int j = n - 2; j >= 0; j--) {
            dp[m-1][j] = Math.max(dp[m-1][j+1]-dungeon[m-1][j], 1);
        }
        for (int i = m - 2; i >= 0; i--) {
            dp[i][n-1] = Math.max(dp[i+1][n-1]-dungeon[i][n-1], 1);
        }
        for (int i = m - 2; i >= 0; i--) {
            for (int j = n - 2; j >= 0; j--) {
                dp[i][j] = Math.max(Math.min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1);
            }
        }
        return dp[0][0];
    }
}
```

方法二：DFS+memo

时间复杂度：O(mn)

空间复杂度：O(mn)

### 120 三角形最小路径和

方法一：动态规划

时间复杂度：O(n^2)

空间复杂度：O(n^2)

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int n = triangle.size();
        int[][] dp = new int[n+1][n+1];
        for (int i = n-1; i >= 0; i--) {
            for (int j = i; j >= 0; j--) {
                dp[i][j] = Math.min(dp[i+1][j], dp[i+1][j+1]) + triangle.get(i).get(j);
            }
        }
        return dp[0][0];
    }
}
```

降低空间复杂度至O(n)

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int n = triangle.size();
        int[] prev = new int[n+1];
        int[] next = new int[n+1];
        for (int i = n-1; i >= 0; i--) {
            for (int j = 0; j <= i; j++) {
                next[j] = Math.min(prev[j], prev[j+1]) + triangle.get(i).get(j);
                prev[j] = next[j];
            }
        }
        return next[0];
    }
}
```

### 113 路径总和 II

方法一： DFS递归

树中结点数为n

时间复杂度：O(n)

空间复杂度：O(n)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        TreeNode curr = root;
        List<List<Integer>> leftSubAns, rightSubAns, ans;
        ans = new LinkedList<>();
        if (curr == null) return ans;
        if (curr.left == null && curr.right == null && curr.val == sum) {
            List<Integer> tmp = new LinkedList<>();
            tmp.add(curr.val);
            ans.add(tmp);
        }
        leftSubAns = pathSum(curr.left, sum-curr.val);
        rightSubAns = pathSum(curr.right, sum-curr.val);
        for (int i = 0; i < leftSubAns.size(); i++) {
            List<Integer> tmp = leftSubAns.get(i);
            tmp.add(0, curr.val);
            ans.add(tmp);
        }
        for (int i = 0; i < rightSubAns.size(); i++) {
            List<Integer> tmp = rightSubAns.get(i);
            tmp.add(0, curr.val);
            ans.add(tmp);
        }
        return ans;
    }
}
```

改写：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>> ans = new LinkedList<>();
        Deque<Integer> path = new LinkedList<>();
        pathSum(root, sum, path, ans);
        return ans;
    }
    public void pathSum(TreeNode node, int sum, Deque path, List ans) {
        if (node == null) return;
        if (node.left == null && node.right == null && sum == node.val) {
            path.addLast(node.val);
            ans.add(new LinkedList<>(path));
            path.removeLast();
        }
        path.addLast(node.val);
        pathSum(node.left, sum-node.val, path, ans);
        pathSum(node.right, sum-node.val, path, ans);
        path.removeLast();
    }
}
```

### 257 二叉树的所有路径

方法一：DFS

结点数为n。

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> ans = new LinkedList<>();
        StringBuffer sb = new StringBuffer();
        binaryTreePaths(root, ans, sb);
        return ans;
    }
    public void binaryTreePaths(TreeNode node, List ans, StringBuffer sb) {
        if (node == null) return;
        String tmp = String.valueOf(node.val);
        if (node.left == null && node.right == null) {
            sb.append(tmp);
            ans.add(sb.toString());
            sb.delete(sb.length()-tmp.length(), sb.length());
        }
        sb.append(tmp);
        sb.append("->");
        binaryTreePaths(node.left, ans, sb);
        binaryTreePaths(node.right, ans, sb);
        sb.delete(sb.length()-tmp.length()-2, sb.length());
    }
}
```

```java
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> ans = new LinkedList<>();
        String path = "";
        binaryTreePaths(root, ans, path);
        return ans;
    }
    public void binaryTreePaths(TreeNode node, List ans, String path) {
        if (node == null) return;
        if (node.left == null && node.right == null) {
            path += node.val;
            ans.add(path);
        }
        path += node.val;
        path += "->";
        binaryTreePaths(node.left, ans, path);
        binaryTreePaths(node.right, ans, path);
    }
}
```

### 785 判断二分图

方法一：BFS

之前写的C：

```c
bool isBipartite(int** graph, int graphSize, int* graphColSize){
    int coloredNode[1000]={0};
    int nodeColor[graphSize];
    for (int i=0; i<graphSize; i++)
    {
        nodeColor[i] = -1;
    }
    int top = 0, tail = 0;
    int flag = 1;
    int curColor = 0;
    nodeColor[0] = 0;
    int curNode;
    while (top < graphSize)
    {
        if (top <= tail)
        {
            curNode = coloredNode[top];
            // printf("%d\n ", curNode);
            curColor = nodeColor[curNode];
            top++;
            for (int i=0; i<graphColSize[curNode]; i++)
            {
                if (nodeColor[graph[curNode][i]] == -1)
                {
                    tail++;
                    coloredNode[tail] = graph[curNode][i];
                    nodeColor[graph[curNode][i]] = 1 - curColor;
                }
                else if (nodeColor[graph[curNode][i]] != 1 - curColor)
                {
                    flag = 0;
                    break;
                }
            }
        }
        else
        {
            for (int i=0; i<graphSize; i++)
            {
                if (nodeColor[i] == -1)
                {
                    coloredNode[top] = i;
                    nodeColor[i] = 0;
                    tail++;
                    break;
                }
            }
        }

        if (flag == 0)
            break;
    }
    return flag;
}
```

假设有n个结点，m个边。

使用染色法，用一个color数组表示每个点的颜色。

时间复杂度：O(m+n)

空间复杂度：O(n)

```java
class Solution {
    public boolean isBipartite(int[][] graph) {
        int n = graph.length;
        int[] color = new int[n];
        Queue<Integer> queue = new PriorityQueue<>();
        for (int i = 0; i < n; i++) {
            int m = graph[i].length;
            if (color[i] == 0) {
                color[i] = 1;
                queue.add(i);
                while (!queue.isEmpty()) {
                    int curr = queue.poll();
                    for (int j = 0; j < graph[curr].length; j++) {
                        int neighbor = graph[curr][j];
                        if (color[neighbor] == 0) {
                            color[neighbor] = 3 - color[curr];
                            queue.add(neighbor);
                        } else if (color[neighbor] == color[curr]) {
                            return false;
                        }
                    }
                }
            }
        }
        return true;
    }
}
```

### 437 路径总和III

方法一：DFS

对每一个结点进行dfs，计算当前结点的路径个数然后相加。结点个数为n

时间复杂度：O(n^2)

空间复杂度：O(n)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int pathSum(TreeNode root, int sum) {
        if (root == null) return 0;
        int ans = 0;
        ans += dfs(root, sum);
        ans += pathSum(root.left, sum);
        ans += pathSum(root.right, sum);
        return ans; 
    }
    public int dfs(TreeNode node, int sum) {
        if (node == null) return 0;
        int ans = 0;
        if (node.val == sum) ans++;
        ans += dfs(node.left, sum-node.val);
        ans += dfs(node.right, sum-node.val);
        return ans;
    }
}
```

方法二：用Hash表构建一个前缀和，记录当前路径上的前缀和，只需用一次DFS即可

时间复杂度：O(n)

空间复杂度：O(n)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int pathSum(TreeNode root, int sum) {
        if (root == null) return 0;
        HashMap<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);
        int ans = helper(root, sum, map, 0);
        return ans;
    }
    public int helper(TreeNode curr, int target, HashMap<Integer, Integer> map, int currSum) {
        if (curr == null) return 0;
        currSum += curr.val;
        int count = map.getOrDefault(currSum-target, 0);
        map.put(currSum, map.getOrDefault(currSum, 0) + 1);
        count += helper(curr.left, target, map, currSum);
        count += helper(curr.right, target, map, currSum);
        map.put(currSum, map.getOrDefault(currSum, 0) - 1);
        return count;
    }   
}
```



### 35 搜索插入位置

方法一：暴力

时间复杂度：O(n)

空间复杂度：O(1)

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int i;
        for (i = 0; i < nums.length; i++) {
            if (nums[i] >= target) {
                return i;
            }
        }
        return i;
    }
}
```

方法二：二分法

时间复杂度：O(log n)

空间复杂度：O(1)

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length-1;
        int mid;
        while (left < right) {
            mid = (left + right) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        if (nums[left] < target) return left+1;
        return left;
    }
}
```

### 53 最大子序和

方法一：动态规划

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];
        int ans = nums[n-1];
        for (int i = n-1; i >= 0; i--) {
            if (i == n-1) {
                dp[i] = nums[i];
            } else if (dp[i+1] < 0) {
                dp[i] = nums[i];
            } else {
                dp[i] = nums[i] + dp[i+1];
            }
            if (dp[i] > ans) ans = dp[i];
        }
        return ans;
    }
}
```

改进版：

空间复杂度：O(1)

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int prev = 0, curr = 0;
        int ans = nums[n-1];
        for (int i = n-1; i >= 0; i--) {
            if (i == n-1) {
                curr = nums[i];
            } else if (prev < 0) {
                curr = nums[i];
            } else {
                curr = nums[i] + prev;
            }
            if (curr > ans) ans = curr;
            prev = curr;
        }
        return ans;
    }
}
```

方法二：分治

`getSum(nums, l, r)` 计算`[l, r]` 区间内的以l为左端点的最大子序列和lSum, 以r为右端点的最大子序列和rSum, `[l, r]`区间和sum, `[l, r]`区间的最大子序列和mSum。

时间复杂度：O(n)

空间复杂度：O(log n)

```java
class Solution {
    class sumStruct {
        int lSum, rSum, mSum, sum;
    }
    public int maxSubArray(int[] nums) {
        sumStruct ans = getSum(nums, 0, nums.length-1);
        return Math.max(Math.max(ans.lSum, ans.rSum), ans.mSum);
    }
    public sumStruct getSum(int[] nums, int l, int r) {
        sumStruct all = new sumStruct();
        if (l == r) {
            all.lSum = nums[l];
            all.rSum = nums[l];
            all.mSum = nums[l];
            all.sum = nums[l];
            return all;
        }
        int mid = (l + r) / 2;
        sumStruct lSub, rSub;
        lSub = getSum(nums, l, mid);
        rSub = getSum(nums, mid+1, r);
        all.lSum = Math.max(lSub.lSum, lSub.sum+rSub.lSum);
        all.rSum = Math.max(rSub.rSum, rSub.sum+lSub.rSum);
        all.sum = lSub.sum + rSub.sum;
        all.mSum = Math.max(Math.max(lSub.mSum, rSub.mSum), lSub.rSum+rSub.lSum);
        return all;
    } 
}
```

### 122 买卖股票的最佳时机II

方法一：单调栈，栈中最多有两个元素，栈底是波底，栈顶是波顶。

时间复杂度：O(n)

空间复杂度：O(1)

```java
class Solution {
    public int maxProfit(int[] prices) {
        Deque<Integer> stack = new LinkedList<>();
        int ans = 0;
        for (int i = 0; i < prices.length; i++) {
            if (stack.size() == 2){
                int tmp = stack.pop();
                if (tmp > prices[i]) {
                    ans += tmp - stack.pop();
                }
            } else if (stack.size() == 1){
                if (stack.peek() >= prices[i]) stack.pop();
            }
            stack.push(prices[i]);
        }
        if (stack.size() == 2) ans += stack.pop() - stack.pop();
        return ans;
    }
}
```

改写：只记录波底和波顶。

时间复杂度：O(n)

空间复杂度：O(1)

```java
class Solution {
    public int maxProfit(int[] prices) {
        int ans = 0;
        int valley;
        int peak;
        int i = 0;
        while (i < prices.length) {
            while (i < prices.length-1 && prices[i] > prices[i+1]) i++;
            valley = prices[i];
            while (i < prices.length-1 && prices[i] < prices[i+1]) i++;
            peak = prices[i];
            ans += peak - valley;
            i++;
        }
        return ans;
    }
}
```

方法三：动态规划

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][2];
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for (int i = 1; i < n; i++) {
            dp[i][1] = Math.max(dp[i-1][0] - prices[i], dp[i-1][1]);
            dp[i][0] = Math.max(dp[i-1][1] + prices[i], dp[i-1][0]);
        }
        return dp[n-1][0];
    }
}
```

### 123 买卖股票的最佳时机 III

方法一：动态规划：

`dp0[i]`表示卖出0次，第i天的情况。`dp0[i][0]`表示不持有股票，`dp0[i][1]`表示持有股票的最大利润

`dp1[i]`表示卖出1次，第i天的情况。。。

`dp2[i]`表示卖出2次的最大利润。

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        if (n == 0) return 0;
        int[][] dp0 = new int[n][2];
        int[][] dp1 = new int[n][2];
        int[] dp2 = new int[n];
        dp0[0][1] = -prices[0];
        dp1[0][0] = Integer.MIN_VALUE;
        dp1[0][1] = Integer.MIN_VALUE;
        dp2[0] = Integer.MIN_VALUE;
        for (int i = 1; i < n; i++) {
            dp0[i][0] = 0;
            dp0[i][1] = Math.max(dp0[i-1][1], -prices[i]);
            dp1[i][0] = Math.max(dp0[i-1][1]+prices[i], dp1[i-1][0]);
            dp1[i][1] = (i == 1)?Integer.MIN_VALUE: Math.max(dp1[i-1][1], dp1[i-1][0]-prices[i]);
            dp2[i] = (i == 1 || i == 2)?Integer.MIN_VALUE: Math.max(dp2[i-1], dp1[i-1][1]+prices[i]);
        }
        return Math.max(Math.max(dp2[n-1], dp1[n-1][0]), 0);
    }
}
```

### 97 交错字符串

方法一：动态规划

s1长度为m,s2长度为n。`dp[i][j]`表示s1前i个字符（不包含第i个）和s2前j个字符（不包含第j个）是否为s3前i+j个字符。

时间复杂度：O(mn)

空间复杂度：O(mn)

```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        int m = s1.length();
        int n = s2.length();
        if (m + n != s3.length()) return false;
        int[][] dp = new int[m+1][n+1];
        dp[0][0] = 1;
        for (int j = 1; j <= n; j++) {
            dp[0][j] = (s2.charAt(j-1) == s3.charAt(j-1))?dp[0][j-1]: 0;
        }
        for (int i = 1; i <= m; i++) {
            dp[i][0] = (s1.charAt(i-1) == s3.charAt(i-1))?dp[i-1][0]: 0;
        }
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                dp[i][j] = (s1.charAt(i-1) == s3.charAt(i+j-1))?dp[i-1][j]:0;
                if (dp[i][j] == 0) dp[i][j] = (s2.charAt(j-1) == s3.charAt(i+j-1))?dp[i][j-1]: 0;
            }
        }
        return (dp[m][n] == 1)?true: false;
    }
}
```

### 312 戳气球

方法一：HashMap的记忆化的递归(超时)

```java
class Solution {
    public int maxCoins(int[] nums) {
        ArrayList<Integer> list = new ArrayList<>(nums.length);
        for (int e: nums) {
            list.add(e);
        }
        HashMap<ArrayList<Integer>, Integer> map = new HashMap<>();
        return helper(list, map);
    }
    public int helper(ArrayList<Integer> list, HashMap<ArrayList<Integer>, Integer> map) {
        if (list.size() == 0) return 0;
        if (list.size() == 1) return list.get(0);
        int ans = 0;
        for (int i = 0; i < list.size(); i++) {
            int tmp = 0;
            int e = list.get(i);
            if (i == 0) {
                tmp += e * list.get(i+1);
            } else if (i == list.size() - 1) {
                tmp += e * list.get(i-1);
            } else {
                tmp += list.get(i-1) * e * list.get(i+1);
            }
            list.remove(i);
            if (map.containsKey(list)) {
                tmp += map.get(list);
                System.out.println(tmp);
            } else {
                int t = helper(list, map);
                map.put(list, t);
                tmp += t;
            }
            list.add(i, e);
            if (tmp > ans) ans = tmp;
        }
        return ans;
    }
}
```

方法二：带有记忆化的递归，可以将戳气球看出添加气球的逆过程。

构建新数组`vals`，使得`vals[i] = nums[i-1]`，这样就包含了`nums[-1], nums[n]` 分别为 `vals[0], vals[n+1]`

令函数`helper(i, j)` 为在`val`s数组中(i, j)位置（不包含i, j）间添加气球直至满的最大硬币。

时间复杂度：O(n^3)

空间复杂度：O(n^2)

```java
class Solution {
    public int maxCoins(int[] nums) {
        int n = nums.length;
        int[] vals = new int[n+2];
        vals[0] = 1;
        for (int i = 1; i <= n; i++) {
            vals[i] = nums[i-1];
        }
        vals[n+1] = 1;
        int[][] mem = new int[n+2][n+2];
        for (int i = 0; i <= n + 1; i++) {
            Arrays.fill(mem[i], -1);
        }
        return helper(0, n+1, vals, mem);
    }
    public int helper(int i, int j, int[] vals, int[][] mem) {
        if (i >= j-1) return 0;
        int ans = 0;
        for (int k = i+1; k < j; k++) {
            int tmp = vals[i] * vals[k] * vals[j];
            tmp += (mem[i][k] == -1)? helper(i, k, vals, mem): mem[i][k];
            tmp += (mem[k][j] == -1)? helper(k, j, vals, mem): mem[k][j];
            if (tmp > ans) ans = tmp;
        }
        mem[i][j] = ans;
        return ans;
    }
}
```

方法三：动态规划

`dp[i][j]` 表示戳破`(i,j)`之间的气球(不包括i,j)得到的硬币，它可以表示为
$$
dp[i][j] = \max_{k \in(i,j)} dp[i][k] + dp[k][j] + vals[i]*vals[k]*vals[j]
$$


时间复杂度：O(n^3)

空间复杂度：O(n^2)

```java
class Solution {
    public int maxCoins(int[] nums) {
        int n = nums.length;
        int[] vals = new int[n+2];
        vals[0] = 1;
        for (int i = 1; i <= n; i++) {
            vals[i] = nums[i-1];
        }
        vals[n+1] = 1;
        int[][] dp = new int[n+2][n+2];
        for (int i = n+1; i >= 0; i--) {
            for (int j = i+1; j <= n+1; j++) {
                dp[i][j] = 0;
                for (int k = i+1; k <= j-1; k++) {
                    int tmp = dp[i][k] + dp[k][j] + vals[i]*vals[j]*vals[k];
                    if (tmp > dp[i][j]) dp[i][j] = tmp;
                }
            }
        }
        return dp[0][n+1];
    }
}
```



### 167 两数之和II-输入有序数组

方法一：双指针

时间复杂度：O(n)

空间复杂度：O(1)

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int l = 0;
        int r = numbers.length - 1;
        int[] ans = new int[2];
        while (l < r) {
            int tmp = numbers[l] + numbers[r];
            if (tmp > target) {
                r--;
            } else if (tmp < target) {
                l++;
            } else {
                ans[0] = l+1;
                ans[1] = r+1;
                break;
            }
        }
        return ans;
    }
}
```

### 2. 两数相加

方法一：链表移动

假设链表最长为n

时间复杂度：O(n)

空间复杂度：O(n)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        int nextP = 0;
        ListNode ans = new ListNode(0);
        ListNode root = ans;
        while (l1 != null || l2 != null) {
            if (l1 != null) {
                ans.val += l1.val;
                l1 = l1.next;
            }
            if (l2 != null) {
                ans.val += l2.val;
                l2 = l2.next;
            }
            ans.val += nextP;
            int tmp = ans.val;
            ans.val = tmp % 10;
            nextP = tmp / 10;
            if (l1 == null && l2 == null) {
                ans.next = (nextP == 1)? new ListNode(1):null;
            } else {
                ans.next = new ListNode(0);
            }
            ans = ans.next;
        }
        return root;
    }
}
```

### 3. 无重复字符的最长子串

方法一：hash+双指针：

字符串长度为n

时间复杂度：O(n)

空间复杂度：O(|C|) ，其中C为所有ascii字符的数量。

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s.length() == 0) return 0;
        HashMap<Character, Integer> map = new HashMap<>();
        int left = 0, right = 1;
        int ans = 1;
        map.put(s.charAt(0), 0);
        while (right < s.length()) {
            char rightChar = s.charAt(right);
            if (!map.containsKey(rightChar)) {
                int tmp = right - left + 1;
                if (tmp > ans) ans = tmp;
            } else {
                int nextLeft = map.get(rightChar) + 1;
                for (int i = left; i < nextLeft; i++) {
                    map.remove(s.charAt(i));
                }
                left = nextLeft;
            }
            map.put(rightChar, right);
            right++;
        }
        return ans;
    }
}
```

代码简介版：

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        if (n == 0) return 0;
        HashMap<Character, Integer> map = new HashMap<>();
        int right = 0;
        int ans = 0;
        for (int left = 0; left < n; left++) {
            while (right < n && !map.containsKey(s.charAt(right))) {
                map.put(s.charAt(right), 0);
                right++;
            }
            ans = Math.max(ans, right - left);
            map.remove(s.charAt(left));
        }  
        return ans;
    }
}
```

### 4 寻找两个正序数组的中位数

方法一：二分查找

时间复杂度：O(log(m+n))

空间复杂度：O(1)

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m = nums1.length;
        int n = nums2.length;
        int totalLength = m + n;
        double ans;
        if (totalLength % 2 == 0) {
            ans = (getKthElement(nums1, nums2, totalLength/2) + getKthElement(nums1, nums2, totalLength/2+1)) / 2.0;
        } else {
            ans = getKthElement(nums1, nums2, totalLength/2+1);
        }
        return ans;
    }
    public int getKthElement(int[] nums1, int[] nums2, int k) {
        int index1 = 0, length1 = nums1.length;
        int index2 = 0, length2 = nums2.length;
        while (true) {
            if (index1 == nums1.length) {
                return nums2[index2+k-1];
            }
            if (index2 == nums2.length) {
                return nums1[index1+k-1];
            }
            if (k == 1) {
                return Math.min(nums1[index1], nums2[index2]);
            }
            int newIndex1 = Math.min(index1+k/2, length1) - 1;
            int nexIndex2 = Math.min(index2+k/2, length2) - 1;
            if (nums1[newIndex1] <= nums2[nexIndex2]) {
                k -= (newIndex1 - index1 + 1);
                index1 = newIndex1+1;
            } else {
                k -= (nexIndex2 - index2 + 1);
                index2 = nexIndex2+1;
            }
        }
    } 
}
```

### 剑指offer 11 旋转数组的最小数字 / 154 寻找旋转排序数组中的最小值 

方法一：二分查找

时间复杂度：O(n)

空间复杂度：O(1)

```java
class Solution {
    public int minArray(int[] numbers) {
        int n = numbers.length;
        return getMin(numbers, 0, n-1);
    }
    public int getMin(int[] numbers, int left, int right) {
        if (left + 1 >= right) return Math.min(numbers[left], numbers[right]);
        int middle = (left + right) / 2;
        if (numbers[middle] < numbers[middle-1] && numbers[middle] < numbers[middle+1]) return numbers[middle];
        int rightMin = getMin(numbers, middle+1,right);
        if (numbers[middle] >= numbers[middle-1] && numbers[middle] <= numbers[middle+1]) {
            return Math.min(getMin(numbers, left, middle), rightMin);
        }
        return rightMin;
    }
}
```

改进版：

时间复杂度: O(log n)，最坏情况下O(n)

```java
class Solution {
    public int minArray(int[] numbers) {
        int n = numbers.length;
        return getMin(numbers, 0, n-1);
    }
    public int getMin(int[] numbers, int left, int right) {
        if (left == right) return numbers[left];
        int middle= (left + right) / 2;
        if (numbers[middle] < numbers[right]) {
            right = middle;
        } else if (numbers[middle] > numbers[right]) {
            left = middle + 1;
        } else {
            right--;
        }
        return getMin(numbers, left, right);
    }
}
```

### 5 最长回文子串

方法一：动态规划

`dp[i][j]`表示下标i和j之间是否为回文串`dp[i][j] = (dp[i+1][j-1] && s[i] == s[j])`

所以按照子串的长度来遍历。

时间复杂度：O(n^2)

空间复杂度：O(n^2)

```java
class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        if (n == 0) return "";
        int[][] dp = new int[n][n];
        int maxLength = 0, left = 0, right = 0;
        for (int l = 0; l < n; l++) {
            for (int i = 0; i + l < n; i++) {
                int j = i + l;
                if (l == 0) {
                    dp[i][j] = 1;
                } else if (l == 1 && s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = 1;
                } else if (dp[i+1][j-1] == 1 && s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = 1;
                }

                if (dp[i][j] == 1 && l+1 > maxLength) {
                    maxLength = l+1;
                    left = i;
                    right = j;
                }
            }
        }
        return s.substring(left, right+1);
    }
}
```

方法二：中心扩展

时间复杂度：O(n^2)

空间复杂度：O(1)

```java
class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        if (n == 0) return "";
        int leftAns = 0, rightAns = 0, maxLength = 0;
        for (int i = 0; i < n; i++) {
            int length1 = helper(s, i, i);
            int length2 = helper(s, i, i+1);
            int tmp = Math.max(length1, length2);
            if (tmp > maxLength) {
                maxLength = tmp;
                leftAns = i - (tmp-1)/2;
                rightAns = leftAns + tmp - 1;
            }
        }
        return s.substring(leftAns, rightAns+1);
    }
    public int helper(String s, int left, int right) {
        int maxLength = 0;
        while (left >= 0 && right < s.length()) {
            if (s.charAt(left) == s.charAt(right)) {
                left--;
                right++;
            } else {
                break;
            }
        }
        return right - left - 1;
    }
}
```

### 6 Z字形变换

方法一：数学方法

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public String convert(String s, int numRows) {
        if (numRows == 1) return s;
        StringBuffer sb = new StringBuffer();
        int circle = 2*numRows - 2;
        int n = s.length();
        for (int i = 0; i < numRows; i++) {
            int index = i;
            int interval = circle - 2*i;
            while (index < n) {
                if (interval == 0) interval = circle - interval;
                sb.append(s.charAt(index));
                index += interval;
                interval = circle - interval;
            }
        }
        return sb.toString();
    }
}
```

### 7 整数反转

方法一：数学方法（有点ugly）

n为整数长度

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public int reverse(int x) {
        int max = Integer.MAX_VALUE;
        int min = Integer.MIN_VALUE;
        int[] maxArray = new int[]{2, 1, 4, 7, 4, 8, 3, 6, 4, 7};
        int maxLength = 10;
        int number = x;
        int ans = 0;
        if (x < 0) {
            if (x == min) return 0;
            number = -x;
        }
        int i = 0, flag = 0, isEqual = 1;
        while (number != 0) {
            int tmp = number % 10;
            if (isEqual == 1) {
                if (tmp > maxArray[i]) {
                    flag = 1;
                    isEqual = 0;
                } else if (tmp < maxArray[i]) {
                    isEqual = 0;
                }
            }
            ans = ans * 10 + tmp;
            number /= 10;
            i++;
        }
        if (i == maxLength && flag == 1) return 0;
        return (x > 0)?ans: -ans;
    }
}
```

### 13 罗马数字转整数

方法一：数学方法

时间复杂度：O(n)

空间复杂度：O(C)

```java
class Solution {
    public int romanToInt(String s) {
        HashMap<Character, Integer> map = new HashMap<>();
        map.put('I', 1);
        map.put('V', 5);
        map.put('X', 10);
        map.put('L', 50);
        map.put('C', 100);
        map.put('D', 500);
        map.put('M', 1000);
        int ans = 0;
        int i = 0;
        while (i < s.length()) {
            if (s.charAt(i) == 'I') {
                if (i+1 < s.length() && s.charAt(i+1) == 'V') {
                    ans += 4;
                    i += 2;
                } else if (i+1 < s.length() && s.charAt(i+1) == 'X') {
                    ans += 9;
                    i += 2;
                } else {
                    ans += 1;
                    i++;
                }
            } else if (s.charAt(i) == 'X') {
                if (i+1 < s.length() && s.charAt(i+1) == 'L') {
                    ans += 40;
                    i += 2;
                } else if (i+1 < s.length() && s.charAt(i+1) == 'C') {
                    ans += 90;
                    i += 2;
                } else {
                    ans += 10;
                    i++;
                }
            } else if (s.charAt(i) == 'C') {
                if (i+1 < s.length() && s.charAt(i+1) == 'D') {
                    ans += 400;
                    i += 2;
                } else if (i+1 < s.length() && s.charAt(i+1) == 'M') {
                    ans += 900;
                    i += 2;
                } else {
                    ans += 100;
                    i++;
                }
            } else {
                ans += map.get(s.charAt(i));
                i++;
            }
        }
        return ans;
    }
}
```

改进版：

```java
class Solution {
    public int romanToInt(String s) {
        int pre = getValue(s.charAt(0));
        int ans = 0;
        for (int i = 1; i < s.length(); i++) {
            int curr = getValue(s.charAt(i));
            if (curr > pre) {
                ans -= pre;
            } else {
                ans += pre;
            }
            pre = curr;
        }
        ans += pre;
        return ans;
    }
    public int getValue(char c) {
        switch (c) {
            case 'I': return 1;
            case 'V': return 5;
            case 'X': return 10;
            case 'L': return 50;
            case 'C': return 100;
            case 'D': return 500;
            case 'M': return 1000;
            default: return 0; 
        }
    }
}
```

### 64 最小路径和

方法一：动态规划

时间复杂度: O(mn)

空间复杂度：O(mn)

```java
class Solution {
    public int minPathSum(int[][] grid) {
        int ans;
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                if (i == m - 1 && j == n - 1) {
                    dp[i][j] = grid[i][j];
                    continue;
                }
                if (i + 1 < m && j + 1 < n) {
                    dp[i][j] = Math.min(dp[i+1][j], dp[i][j+1]) + grid[i][j];
                } else if (j + 1 < n) {
                    dp[i][j] = dp[i][j+1] + grid[i][j];
                } else{
                    dp[i][j] = dp[i+1][j] + grid[i][j];
                }
            }
        }
        return dp[0][0];
    }
}
```

### 8 字符串转换整数

方法一：数学方法

字符串长度为n

时间复杂度：O(n)

空间复杂度：O(1)

```java
class Solution {
    public int myAtoi(String str) {
        int isNegative = 0;
        int ans = 0;
        int numberStart = 0;
        for (int i = 0; i < str.length(); i++) {
            if (getValue(str.charAt(i)) == -2 || (numberStart == 1 && str.charAt(i) == ' ')) break;
            if (str.charAt(i) == '-') {
                if (numberStart == 1) break;
                isNegative = 1;
                numberStart = 1;
            } else if (str.charAt(i) == '+') {
                if (numberStart == 1) break;
                numberStart = 1;
            }
            if (str.charAt(i) >= '0' && str.charAt(i) <= '9') {
                int e = str.charAt(i) - '0';
                if (isNegative == 1) {
                    e = -e;
                    if (ans < Integer.MIN_VALUE/10 || (ans == Integer.MIN_VALUE/10 && e < Integer.MIN_VALUE%10)) return Integer.MIN_VALUE;
                } else {
                    if (ans > Integer.MAX_VALUE/10 || (ans == Integer.MAX_VALUE/10 && e > Integer.MAX_VALUE%10)) return Integer.MAX_VALUE;

                }
                ans = ans * 10 + e;
                numberStart = 1;
            }
        }
        return ans;
    }
    public int getValue(char c) {
        switch(c) {
            case '-': return -1;
            case '+': return 10;
            case '0': return 0;
            case '1': return 1;
            case '2': return 2;
            case '3': return 3;
            case '4': return 4;
            case '5': return 5;
            case '6': return 6;
            case '7': return 7;
            case '8': return 8;
            case '9': return 9;
            case ' ': return -3;
            default: return -2;
        }
    }
}
```

方法二：自动机

时间复杂度：O(n)

空间复杂度：O(1)

```java
class Solution {
    class Automation {
        String START = "start";
        String SIGNED = "signed";
        String INNUMBER = "inNumber";
        String END = "end";
        HashMap<String, String[]> map;
        String state = START;
        int ans = 0;
        int isNegative = 0;
        public Automation() {
            map = new HashMap<>();
            map.put(START, new String[]{START, SIGNED, INNUMBER, END});
            map.put(SIGNED, new String[]{END, END, INNUMBER, END});
            map.put(INNUMBER, new String[]{END, END, INNUMBER, END});
            map.put(END, new String[]{END, END, END, END});
        }
        public int getValue(char c) {
            if (c == ' ') return 0;
            if (c == '+' || c == '-') return 1;
            if (c >= '0' && c <= '9') return 2;
            return 3;
        }
        public void get(char c) {
            int index = getValue(c);
            state = map.get(state)[index];
            if (state == SIGNED) {
                if (c == '-') isNegative = 1;
            } else if (state == INNUMBER) {
                int e = c - '0';
                if (isNegative == 1) {
                    e = -e;
                    if (ans < Integer.MIN_VALUE/10 || (ans == Integer.MIN_VALUE/10 && e < Integer.MIN_VALUE%10)) {
                        ans = Integer.MIN_VALUE;
                        state = END;
                    } else {
                        ans = 10 * ans + e;
                    }
                } else {
                    if (ans > Integer.MAX_VALUE/10 || (ans == Integer.MAX_VALUE/10 && e > Integer.MAX_VALUE%10)) {
                        ans = Integer.MAX_VALUE;
                        state = END;
                    } else {
                        ans = 10 * ans + e;
                    }
                }
            }
        }
    }
    public int myAtoi(String str) {
        Automation auto = new Automation();
        for (int i = 0; i < str.length(); i++) {
            auto.get(str.charAt(i));
        }
        return auto.ans;
    }
}
```

### 17 电话号码的字母组合

方法一：直接

m为3个字符的数字个数，n为4个字符的数字个数

时间复杂度：O(3^m * 4^n)

空间复杂度：O(3^m * 4^n)

```java
class Solution {
    public List<String> letterCombinations(String digits) {
        List<String> prev = new LinkedList<>();
        prev.add("");
        List<String> curr = new LinkedList<>();
        HashMap<Character, char[]> map = new HashMap<>();
        map.put('2', new char[]{'a', 'b', 'c'});
        map.put('3', new char[]{'d', 'e', 'f'});
        map.put('4', new char[]{'g', 'h', 'i'});
        map.put('5', new char[]{'j', 'k', 'l'});
        map.put('6', new char[]{'m', 'n', 'o'});
        map.put('7', new char[]{'p', 'q', 'r', 's'});
        map.put('8', new char[]{'t', 'u', 'v'});
        map.put('9', new char[]{'w', 'x', 'y', 'z'});
        for (int i = 0; i < digits.length(); i++) {
            char number = digits.charAt(i);
            char[] chars = map.get(number);
            curr = new LinkedList<>();
            for (char c: chars) {
                for (String str: prev) {
                    StringBuffer sb = new StringBuffer(str);
                    sb.append(c);
                    curr.add(sb.toString());
                }
            }
            prev = curr;
        }
        return curr;
    }
}
```

方法二：递归

```java
class Solution {
    int n;
    List<String> ans;
    HashMap<Character, String> map;
    public List<String> letterCombinations(String digits) {
        n = digits.length();
        map = new HashMap<>();
        ans = new LinkedList<>();
        map.put('2', "abc");
        map.put('3', "def");
        map.put('4', "ghi");
        map.put('5', "jkl");
        map.put('6', "mno");
        map.put('7', "pqrs");
        map.put('8', "tuv");
        map.put('9', "wxyz");
        if (n != 0) dfs("", 0, digits);
        return ans;
    }
    public void dfs(String combine, int index, String digits) {
        if (index == n) {
            ans.add(combine);
            return;
        }
        String str = map.get(digits.charAt(index));
        for (int i = 0; i < str.length(); i++) {
            dfs(combine + str.substring(i, i+1), index+1, digits);
        }
    }
}
```

### 18 四数之和

方法一：双指针

时间复杂度：O(n^3)

空间复杂度：O(C)

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> ans = new LinkedList<>();
        int n = nums.length;
        Arrays.sort(nums);
        for (int i = 0; i <= n-4; i++) {
            if (i > 0 && nums[i] == nums[i-1]) continue;
            for (int j = i+1; j <= n-3; j++) {
                if (j > i+1 && nums[j] == nums[j-1]) continue;
                int sum = (target - nums[i] - nums[j]);
                int left = j + 1;
                int right = n - 1;
                while (left < right) {
                    if (left > j+1 && nums[left] == nums[left-1]) {
                        left++;
                        continue;
                    }
                    if (right < n-1 && nums[right] == nums[right+1]) {
                        right--;
                        continue;
                    }
                    if (nums[left] + nums[right] > sum) {
                        right--;
                    } else if (nums[left] + nums[right] < sum) {
                        left++;
                    } else {
                        List<Integer> tmp = new LinkedList<>();
                        tmp.add(nums[i]);
                        tmp.add(nums[j]);
                        tmp.add(nums[left]);
                        tmp.add(nums[right]);
                        ans.add(tmp);
                        left++;
                        right--;
                    }
                }
            }
        }
        return ans;
    }
}
```

### 1025 除数博弈

方法一：带memo的递归

时间复杂度：O(n^2)

空间复杂度：O(n)

```java
class Solution {
    public boolean divisorGame(int N) {
        int[] memo = new int[N+1];
        for (int i = 0; i < N; i++) {
            memo[i] = -1;
        }
        return divisorGameMemo(N, memo);
    }
    public boolean divisorGameMemo(int N, int[] memo) {
        for (int i = 1; i < N; i++) {
            if (N % i == 0) {
                if (memo[N-i] == 0 || (memo[N-i] == -1 && !divisorGameMemo(N-i, memo))) {
                    memo[N] = 1;
                    return true;
                }
            }
        }
        memo[N] = 0;
        return false;
    }
}
```

方法二：动态规划

时间复杂度：O(n^2)

时间复杂度：O(n)

### 19 删除链表的倒数第N个结点

方法一：双指针，一次遍历

时间复杂度：O(N)

空间复杂度：O(1)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode sentiNode = new ListNode(0);
        sentiNode.next = head;
        ListNode left = sentiNode;
        ListNode right = sentiNode;
        for (int i = 0; i < n; i++) {
            right = right.next;
        }
        while (right.next != null) {
            left = left.next;
            right = right.next;
        }
        left.next = left.next.next;
        return sentiNode.next;
    }
}
```

### 11 盛最多水的容器

方法一：双指针

维持两个指针:left, right。取当前left和right位置上的较小的那个，让其移动直到一个位置使得那个位置上的数大于原位置的数。

时间复杂度：O(n)

空间复杂度：O(1)

```java
class Solution {
    public int maxArea(int[] height) {
        int n = height.length;
        int left = 0, right = n - 1;
        int ans = 0;
        while (left < right) {
            int tmp = (right - left) *  Math.min(height[left], height[right]);
            ans = Math.max(ans, tmp);
            if (height[left] < height[right]) {
                tmp = left;
                while (left < right && height[tmp] >= height[left]) {
                    left++;
                }
            } else {
                tmp = right;
                while (left < right && height[tmp] >= height[right]) {
                    right--;
                }
            }
        }
        return ans;
    }
}
```

### 12 整数转罗马数字

方法一：直接

假设num的位数为n

时间复杂度：O(n)

空间复杂度：O(1)

```java
class Solution {
    public String intToRoman(int num) {
        StringBuffer sb = new StringBuffer();
        int digit = 1;
        while (num != 0) {
            int number = (num % 10) * digit;
            int tmp1 = number / (5 * digit);
            int tmp2 = number % (5 * digit);
            digit *= 10;
            num /= 10;
            if (number >= 1 && number <= 9) {
                if (tmp1 == 0) {
                    if (tmp2 == 4) {
                        sb.insert(0, "IV");
                    } else {
                        helper(sb, tmp2, 'I');
                    }
                } else {
                    if (tmp2 == 4) {
                        sb.insert(0, "IX");
                    } else {
                        helper(sb, tmp2, 'I');
                        sb.insert(0, 'V');
                    }
                }
            } else if (number >= 10 && number <= 90) {
                if (tmp1 == 0) {
                    if (tmp2 == 10) {
                        sb.insert(0, 'X');
                    } else if (tmp2 == 40) {
                        sb.insert(0, "XL");
                    } else {
                        helper(sb, tmp2/10, 'X');
                    }
                } else {
                    if (tmp2 == 40) {
                        sb.insert(0, "XC");
                    } else {
                        helper(sb, tmp2/10, 'X');
                        sb.insert(0, 'L');
                    }
                }
            } else if (number >= 100 && number <= 900) {
                if (tmp1 == 0) {
                    if (tmp2 == 100) {
                        sb.insert(0, 'C');
                    } else if (tmp2 == 400) {
                        sb.insert(0, "CD");
                    } else {
                        helper(sb, tmp2/100, 'C');
                    }
                } else {
                    if (tmp2 == 400) {
                        sb.insert(0, "CM");
                    } else {
                        helper(sb, tmp2/100, 'C');
                        sb.insert(0, 'D');
                    }
                }
            } else if (number >= 1000){
                helper(sb, number/1000, 'M');
            }
        }
        return sb.toString();
    }

    public void helper(StringBuffer sb, int num, char c) {
        for (int i = 0; i < num; i++) {
            sb.insert(0, c);
        }
    }
}
```

方法二：贪心

时间复杂度：O(1)

空间复杂度：O(1)

```java
class Solution {
    public String intToRoman(int num) {
        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};    
        String[] symbols = {"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < values.length; i++) {
            while (num >= values[i]) {
                sb.append(symbols[i]);
                num -= values[i];
            }
        }
        return sb.toString();
    }
}
```

### 21 合并两个有序链表

方法一：直接

时间复杂度：O(n)

空间复杂度：O(1)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode sentiNode = new ListNode(0);
        ListNode curr = sentiNode;
        while (l1 != null || l2 != null) {
            if (l1 == null) {
                curr.next = l2;
                break;
            } else if (l2 == null) {
                curr.next = l1;
                break;
            } else {
                if (l1.val <= l2.val) {
                    curr.next = l1;
                    l1 = l1.next;
                } else {
                    curr.next = l2;
                    l2 = l2.next;
                }
                curr = curr.next;
            }
        }
        return sentiNode.next;
    }
}
```

### 410 分割数组的最大值

方法一：动态规划

`dp[i][j]`表示从下标i开始到数组末尾，分割成j个数组的最小最大值。需要注意数组中有2^32-1的情况。
$$
dp[i][j] = \min_{i+1 \leq  k \leq n-j+1} (\max (dp[k][j-1], sum[i,...,k]))
$$
时间复杂度：O(n^2*m)

空间复杂度：O(nm)



```java
class Solution {
    public int splitArray(int[] nums, int m) {
        int n = nums.length;
        int[][] dp = new int[n][m+1];
        for (int i = n-1; i >= 0; i--) {
            if (i != n - 1) {
                if (nums[i] >= Integer.MAX_VALUE - dp[i+1][1]) {
                    dp[i][1] = Integer.MAX_VALUE;
                } else {
                    dp[i][1] = dp[i+1][1] + nums[i];
                }
            } else {
                dp[i][1] = nums[i];
            }
        }
        for (int i = n-1; i >= 0; i--) {
            for (int j = 2; j <= Math.min(m, n-i); j++) {
                int tmp = nums[i];
                dp[i][j] = Integer.MAX_VALUE;
                for (int k = i+1; k <= n-j+1; k++) {
                    dp[i][j] = Math.min(dp[i][j], Math.max(tmp, dp[k][j-1]));
                    if (nums[k] >= Integer.MAX_VALUE - tmp) {
                        tmp = Integer.MAX_VALUE;
                    } else {
                        tmp += nums[k];
                    }
                }
            }
        }
        return dp[0][m];
    }
}
```

### 329 矩阵中的最长递增路径

方法一：DFS+memo

时间复杂度：O(mn)

空间复杂度：O(mn)

```java
class Solution {
    int[][] index = {{-1,0}, {1,0}, {0,-1}, {0,1}};
    int m, n;
    public int longestIncreasingPath(int[][] matrix) {
        m = matrix.length;
        if (m == 0) return 0;
        n = matrix[0].length;
        int[][] memo = new int[m][n];
        int ans = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (memo[i][j] != 0) continue;
                int tmp = longestIncreasingPath(matrix, i, j, memo);
                ans = Math.max(ans, tmp);
            }
        }
        return ans;
    }
    public int longestIncreasingPath(int[][] matrix, int i, int j, int[][] memo) {
        int curr = matrix[i][j];
        int maxPathLength = 1;
        for (int k = 0; k < 4; k++) {
            int p = index[k][0]+i, q = index[k][1]+j;
            int currPathLength = 1;
            if (p >= 0 && p < m && q >= 0 && q < n && matrix[p][q] > curr) {
                if (memo[p][q] != 0) {
                    currPathLength += memo[p][q];
                } else {
                    currPathLength += longestIncreasingPath(matrix, p, q, memo);
                }
            }
            if (currPathLength > maxPathLength) {
                maxPathLength = currPathLength;
            }   
        }
        memo[i][j] = maxPathLength;
        return maxPathLength;
    }
}
```

### 22 括号生成

方法一：递归

时间复杂度：$O(\frac{4^n}{n^{\frac{1}{2}}})$

空间复杂度：O(n)

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> ans = new LinkedList<>();
        StringBuffer sb = new StringBuffer();
        generateParenthesis(ans, 0, 0, sb, n);
        return ans;
    }
    public void generateParenthesis(List<String> ans, int left, int right, StringBuffer sb, int n) {
        if (left+right == n * 2) {
            ans.add(sb.toString());
        }
        if (left < n) {
            sb.append('(');
            generateParenthesis(ans, left+1, right, sb, n);
            sb.delete(sb.length()-1, sb.length());
        }
        if (right < left) {
            sb.append(')');
            generateParenthesis(ans, left, right+1, sb, n);
            sb.delete(sb.length()-1, sb.length());
        }
    }
}
```

### 392 判断子序列

方法一：一次遍历

s串长度m，t串长度n

时间复杂度：O(m+n)

空间复杂度：O(1)

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        int j = 0;
        for (int i = 0; i < s.length(); i++) {
            while (j < t.length() && t.charAt(j) != s.charAt(i)) {
                j++;
            }
            if (j == t.length()) return false;
            j++;
        }
        return true;
    }
}
```

### 48 旋转图像

方法一：先转置，再对每行反转

时间复杂度：O(n^2)

空间复杂度：O(1)

```java
class Solution {
    public void rotate(int[][] matrix) {
        // transpose
        int n = matrix.length;
        for (int i  = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = tmp;
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n/2; j++) {
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[i][n-j-1];
                matrix[i][n-j-1] = tmp;
            }
        }
    }
}
```

### 24 两两交换链表中的节点

方法一：构造sentiNode，用prev，next。

时间复杂度：O(n)

空间复杂度：O(1)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode sentiNode = new ListNode(0);
        ListNode prev = sentiNode;
        prev.next = head;
        ListNode curr = head;
        while (curr != null) {
            if (curr.next == null) break;
          	//交换
            prev.next = curr.next;
            curr.next = prev.next.next;
            prev.next.next = curr;
          	//下一步操作
            prev = curr;
            curr = prev.next;
        }
        return sentiNode.next;
    }
}
```

### 25 K个一组翻转链表

方法一：使用sentiNode, prev, curr。对于每个需要翻转的部分，从前到后一个一个翻转

时间复杂度：O(n)

空间复杂度：O(1)

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode sentiNode = new ListNode(0);
        sentiNode.next = head;
        ListNode prev = sentiNode;
        ListNode curr = head;
        while (curr != null) {
            int i = 0;
            ListNode tmp = prev;
          //判断是否当前有k个结点，如果有则翻转
            while (i < k && tmp != null) {
                tmp = tmp.next;
                i++;
            }
            if (tmp == null) break;
          // 翻转
            for (i = 0; i < k-1; i++) {
                tmp = curr.next;
                curr.next = tmp.next;
                tmp.next = prev.next;
                prev.next = tmp;
            }
            prev = curr;
            curr = prev.next;
        }
        return sentiNode.next;
    }
}
```

### 26 删除排序数组中的重复项

方法一：双指针

时间复杂度：O(n)

空间复杂度：O(1)

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int n = nums.length;
        int left = 0;
        int right = 1;
        while (right < n) {
            if (nums[left] >= nums[right]) {
                right++;
            } else {
                nums[++left] = nums[right++]; 
            }
        }
        return left+1;
    }
}
```

### 27 移除元素

方法一：双指针

时间复杂度：O(n)

空间复杂度：O(1)

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int n = nums.length;
        int left = 0;
        while (left < n && nums[left] != val) {
            left++;
        }
        int right = left + 1;
        while (right < n) {
            while (right < n && nums[right] == val) {
                right++;
            }
            if (right == n) break;
            nums[left++] = nums[right++];
        }
        return left;
    }
}
```

### 104 二叉树的最大深度

方法一：递归

设结点数为n

时间复杂度：O(n)

空间复杂度：O(n)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
```

### 28 实现strStr()

方法一：双指针

时间复杂度：O(mn)

空间复杂度：O(1)

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle.equals("")) return 0;
        int m = haystack.length();
        int n = needle.length();
        for (int i = 0; i <= m-n; i++) {
            int j;
            for (j = 0; j < n; j++) {
                if (haystack.charAt(i+j) != needle.charAt(j)) break;
            }
            if (j == n) return i;
        }
        return -1;
    }
}
```

### 29 两数相除

方法一：直接

时间复杂度：O(log (n))

空间复杂度：O(1)

```java
class Solution {
    public int divide(int dividend, int divisor) {
        int ans = 0;
        int isNegative = 0;
        if (dividend < 0 && divisor > 0 || dividend > 0 && divisor < 0) {
            isNegative = 1;
        }
        if (dividend == Integer.MIN_VALUE) {
            if (divisor == 1) return Integer.MIN_VALUE;
            if (divisor == -1) return Integer.MAX_VALUE;
            if (divisor == Integer.MIN_VALUE) return 1;
            dividend = (divisor > 0)? dividend + divisor: dividend - divisor;
            ans++;
        }
        if (divisor == Integer.MIN_VALUE) {
            return 0;
        } 
        dividend = (dividend < 0)? -dividend: dividend;
        divisor = (divisor < 0)? -divisor: divisor;
        while (dividend >= divisor) {
            int tmp1 = 1;
            int tmp2 = divisor;
            while (tmp2 <= dividend - tmp2) {
                tmp1 += tmp1;
                tmp2 += tmp2;
            }
            dividend -= tmp2;
            ans += tmp1;
        }
        return (isNegative == 1)?-ans: ans;
    }
}
```

### LCP 13 寻宝

方法一：动态规划

假设迷宫面积为s，M的数量为m，O的数量为o

时间复杂度：$O(ms + m^2o+2^mm^2)$

空间复杂度：$O(s+bs+2^mm)$

```java
class Solution {
    int m, n;
    int[] dx = {-1, 1, 0, 0};
    int[] dy = {0, 0, -1, 1};
    public int minimalSteps(String[] maze) {
        m = maze.length;
        n = maze[0].length();
        int sx = -1, sy = -1, tx = -1, ty = -1;
        List<int[]> buttons = new ArrayList<>();
        List<int[]> stones = new ArrayList<>();
        int buttonSize = 0, stoneSize = 0;
        // 遍历maze，start,target和所有机关和石头的位置
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                char tmp = maze[i].charAt(j);
                if (tmp == 'S') {
                    sx = i;
                    sy = j;
                } else if (tmp == 'T') {
                    tx = i;
                    ty = j;
                } else if (tmp == 'M') {
                    buttons.add(new int[]{i, j});
                } else if (tmp == 'O') {
                    stones.add(new int[]{i, j});
                }
            }
        }
        buttonSize = buttons.size();
        stoneSize = stones.size();

        // start到每个点的最小距离
        int[][] dStart = bfs(sx, sy, maze);

        // 没有机关的情况
        if (buttonSize == 0) {
            return dStart[tx][ty];
        }

        // 每个button到其他button和起点终点的最小距离(经过一次stone)
        int[][] dist = new int[buttonSize][buttonSize+2];
        for (int i = 0; i < buttonSize; i++) {
            Arrays.fill(dist[i], -1);
        }

        // 每个button到其他位置的距离
        int[][][] dButtons = new int[buttonSize][][];
        for (int i = 0; i < buttonSize; i++) {
            int[][] d = bfs(buttons.get(i)[0], buttons.get(i)[1], maze);
            dButtons[i] = d;
            dist[i][buttonSize+1] = d[tx][ty];
        }

        for (int i = 0; i < buttonSize; i++) {
            int tmp = -1;
            for (int j = 0; j < stoneSize; j++) {
                int xStone = stones.get(j)[0], yStone = stones.get(j)[1];
                if (dButtons[i][xStone][yStone] != -1 && dStart[xStone][yStone] != -1) {
                    if (tmp == -1 || tmp > dButtons[i][xStone][yStone]+dStart[xStone][yStone])
                        tmp = dButtons[i][xStone][yStone]+dStart[xStone][yStone];
                }
            }
            dist[i][buttonSize] = tmp;

            for (int j = i+1; j < buttonSize; j++) {
                tmp = -1;
                for (int k = 0; k < stoneSize; k++) {
                    int xStone = stones.get(k)[0], yStone = stones.get(k)[1];
                    if (dButtons[i][xStone][yStone] != -1 && dButtons[j][xStone][yStone] != -1) {
                        if (tmp == -1 || tmp > dButtons[i][xStone][yStone]+dButtons[j][xStone][yStone])
                            tmp = dButtons[i][xStone][yStone]+dButtons[j][xStone][yStone];
                    }
                }
                dist[i][j] = tmp;
                dist[j][i] = tmp;
            }
        }

        // 无法拿到宝藏的情况
        for (int i = 0; i < buttonSize; i++) {
            if (dist[i][buttonSize] == -1 || dist[i][buttonSize+1] == -1) return -1;
        }

        // 构造dp
        int[][] dp = new int[1 << buttonSize][buttonSize];
        for (int i = 0; i < 1<<buttonSize; i++) {
            Arrays.fill(dp[i], -1);
        }
        for (int i = 0; i < buttonSize; i++) {
            dp[1<<i][i] = dist[i][buttonSize];
        }
        for (int mask = 1; mask < 1<<buttonSize; mask++) {
            for (int i = 0; i < buttonSize; i++) {
                if ((mask & (1<<i)) != 0) {
                    for (int j = 0; j < buttonSize; j++) {
                        if ((mask & (1<<j)) == 0) {
                            int next = mask|(1<<j);
                            if (dp[next][j] == -1 || dp[next][j] > dp[mask][i]+dist[i][j])
                                dp[next][j] = dp[mask][i]+dist[i][j];
                        }
                    }
                }
            }
        }

        int ans = -1;
        for (int i = 0; i < buttonSize; i++) {
            if (ans == -1 || ans > dp[(1<<buttonSize)-1][i]+dButtons[i][tx][ty])
                ans =dp[(1<<buttonSize)-1][i]+dButtons[i][tx][ty];
        }
        return ans;

    }
    public int[][] bfs(int x, int y, String[] maze) {
        int[][] ret = new int[m][n];
        for (int i = 0; i < m; i++) {
            Arrays.fill(ret[i], -1);
        }
        ret[x][y] = 0;
        Queue<int[]> queue = new LinkedList<int[]>();
        queue.offer(new int[]{x, y});
        while (queue.size() != 0) {
            int[] p = queue.poll();
            for (int i = 0; i < 4; i++) {
                int xNeibor = p[0] + dx[i], yNeibor = p[1] + dy[i];
                if (inBound(xNeibor, yNeibor) && maze[xNeibor].charAt(yNeibor) != '#' && ret[xNeibor][yNeibor] == -1) {
                    ret[xNeibor][yNeibor] = ret[p[0]][p[1]] + 1;
                    queue.offer(new int[]{xNeibor, yNeibor});
                }  
            }
        }
        return ret;
    }
    public boolean inBound(int x, int y) {
        if (x >= 0 && x < m && y >= 0 && y < n) {
            return true;
        } else {
            return false;
        }
    }
}
```

### 343 整数拆分

方法一：递归+memo

时间复杂度：O(n^2)

空间复杂度：O(n)

```java
class Solution {
    public int integerBreak(int n) {
        int[] memo = new int[n+1];
        if (n == 3) return 2;
        if (n == 2) return 1;
        return integerBreakMemo(n, memo);
    }
    public int integerBreakMemo(int x, int[] memo) {
        if (x == 1) return 1;
        int ans = x;
        for (int i = 1; i < x; i++) {
            if (memo[x-i] != 0) {
                ans = Math.max(ans, memo[x-i]*i);
            } else {
                ans = Math.max(ans, integerBreakMemo(x-i, memo));
            }
        }
        memo[x] = ans;
        return ans;
    }
}
```

### 30 串联所有单词的子串

方法一：Hashmap+双指针

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        List<Integer> ans = new ArrayList<>();
        if (words.length == 0) return ans;
        int wordLength = words[0].length();
        int wordsLength = words.length;
        HashMap<String, Integer> map = new HashMap<>();
        for (String word: words) {
            map.put(word, map.getOrDefault(word, 0)+1);
        }
        for (int i = 0; i < s.length(); i++) {
            HashMap<String, Integer> tmp = new HashMap<>();
            int j = i;
            int count = 0;
            while (count != wordsLength && j + wordLength <= s.length()) {
                String subString = s.substring(j, j+wordLength);
                int x = map.getOrDefault(subString, 0);
                if (x == 0) break; 
                tmp.put(subString, tmp.getOrDefault(subString, 0)+1);
                if (tmp.get(subString) > x) break;
                count++;
                j += wordLength; 
            }
            if (count == wordsLength) ans.add(i);
        }
        return ans;
    }
}
```

优化版：

```java
class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        List<Integer> ans = new ArrayList<>();
        if (words.length == 0) return ans;
        int oneWordLength = words[0].length();
        int wordsSize = words.length;
        HashMap<String, Integer> map = new HashMap<>();
        for (String word: words) {
            map.put(word, map.getOrDefault(word, 0)+1);
        }
        for (int i = 0; i < oneWordLength; i++) {
            int left = i, right = i;
            int count = 0;
            HashMap<String, Integer> tmp = new HashMap<>(); 
            while (right + oneWordLength <= s.length()) {
                String subString = s.substring(right, right+oneWordLength);
                int x = map.getOrDefault(subString, 0);
                right += oneWordLength;
                if (x == 0) {
                    left = right;
                    count = 0;
                    tmp.clear();
                } else {
                    tmp.put(subString, tmp.getOrDefault(subString, 0)+1);
                    count++;
                    while (tmp.get(subString) > x) {
                        String leftSubString = s.substring(left, left+oneWordLength);
                        tmp.put(leftSubString, tmp.get(leftSubString)-1);
                        left += oneWordLength;
                        count--;                            
                    }
                    if (count == wordsSize) {
                        ans.add(left);
                    }
                }
            }
        }
        return ans;
    }
}
```

### 31 下一个排列

方法一：一次遍历。找到数列最后递增的地方，和后面递减的正好大于数列递增的那个位置。

时间复杂度：O(n)

空间复杂度：O(1)

```java
class Solution {
    public void nextPermutation(int[] nums) {
        int n = nums.length;
        int i = 0;
        int rightIncrease = -1;
        int rightDecrease = -1;
        while (i < n-1) {
            if (i + 1 < n && nums[i+1] > nums[i]) {
                while (i + 1 < n && nums[i+1] > nums[i]) {
                    i++;
                }
                rightIncrease = i;
            }
            rightDecrease = rightIncrease;
            while (i + 1 < n && nums[i+1] <= nums[i]) {
                if (rightIncrease != -1 && nums[i+1] > nums[rightIncrease-1]) rightDecrease = i+1;
                i++;
            }
        }
        if (rightIncrease == -1) {
            sort(0, nums);
        } else {
            if (rightIncrease == n-1) {
                swap(rightIncrease-1, rightIncrease, nums);
            } else {
                swap(rightDecrease, rightIncrease-1, nums);
                sort(rightIncrease, nums);
            }
        }
    }
    public void swap(int i, int j, int[] nums) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
    public void sort(int i, int[] nums) {
        int n = nums.length;
        for (int k = i; k <= (n-1+i)/2; k++) {
            swap(k, n-1-(k-i), nums);
        }
    }
}
```

### 33 搜索旋转排序数组

方法一：分治

时间复杂度：O(log n)

空间复杂度：O(1)

```java
class Solution {
    public int search(int[] nums, int target) {
        return search(nums, 0, nums.length-1, target);
    }
    public int search(int[] nums, int left, int right, int target) {
        if (left > right) return -1;
        if (left == right) {
            if (nums[left] == target) return left;
            return -1;
        }
        int middle = (left + right) / 2;
        if (nums[middle] == target) return middle;
        if (nums[middle] <= nums[right]) {
            if (target > nums[right]) {
                return search(nums, left, middle-1, target);
            } else {
                if (target > nums[middle]) {
                    return search(nums, middle+1, right, target);
                } else {
                    return search(nums, left, middle-1, target);
                }
            }
        } else {
            if (target > nums[middle]) {
                return search(nums, middle+1, right, target);
            } else {
                if (target > nums[right]) {
                    return search(nums, left, middle-1, target);
                } else {
                    return search(nums, middle+1, right, target);
                }
            }
        }
    }
}
```

### 34 在排序数组中查找元素的第一个和最后一个位置

方法一：分治

时间复杂度：O(log n)

空间复杂度：O(log n)

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] ans = new int[]{-1, -1};
        int n = nums.length;
        searchRange(nums, target, 0, n-1, ans);
        if (ans[0] != -1) {
            // 找left
            int left = ans[0], right = (ans[0] + ans[1]) / 2;;
            while (left < right) {
                int middle = (left + right) / 2;
                if (nums[middle] == target) {
                    right = middle;
                } else {
                    left = middle+1;
                }
            }
            int ansLeft = left;
            // 找right
            left = (ans[0] + ans[1]) / 2;
            right = ans[1];
            while (left < right) {
                int middle = (left + right + 1) / 2;
                if (nums[middle] == target) {
                    left = middle;
                } else {
                    right = middle-1;
                }
            }
            int ansRight = right;
            ans[0] = ansLeft;
            ans[1] = ansRight;
        }
        return ans;
    }
    public void searchRange(int[] nums, int target, int left, int right, int[] ans) {
        if (left > right) return;
        int middle = (left + right) / 2;
        if (nums[middle] == target) {
            ans[0] = left;
            ans[1] = right;
            return;
        }
        if (nums[middle] > target) {
            searchRange(nums, target, left, middle-1, ans);
        } else {
            searchRange(nums, target, middle+1, right, ans);
        }
    }
}
```

### 36 有效的数独

方法一：Hash

时间复杂度：O(1)

空间复杂度：O(1)

```java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        for (int i = 0;i < 9; i++) {
            if (!checkRow(board, i)) return false;
            if (!checkCol(board, i)) return false;
            if (!checkSquare(board, i)) return false;
        }
        return true;
    }

    public boolean checkRow(char[][] board, int row) {
        HashMap<Character, Integer> map = new HashMap<>();
        for (int j = 0; j < 9; j++) {
            char curr = board[row][j];
            if (curr != '.') {
                if (map.containsKey(curr)) return false;
                map.put(curr, 0);
            }
        }
        return true;
    }
    public boolean checkCol(char[][] board, int col) {
        HashMap<Character, Integer> map = new HashMap<>();
        for (int j = 0; j < 9; j++) {
            char curr = board[j][col];
            if (curr != '.') {
                if (map.containsKey(curr)) return false;
                map.put(curr, 0);
            }
        }
        return true;
    }
    public boolean checkSquare(char[][] board, int index) {
        HashMap<Character, Integer> map = new HashMap<>();
        int row = index/3 * 3;
        int col = index%3 * 3;
        for (int i = row; i < row+3; i++) {
            for (int j = col; j < col+3; j++) {
                char curr = board[i][j];
                if (curr != '.') {
                    if (map.containsKey(curr)) return false;
                    map.put(curr, 0);
                }
            }
        }
        return true;
    }
}
```

### 37 解数独

方法一：递归

时间复杂度：O((9!)^9))

空间复杂度：O(81)

```java
class Solution {
    HashMap<Character, Integer>[] rowMap = new HashMap[9];
    HashMap<Character, Integer>[] colMap = new HashMap[9];
    HashMap<Character, Integer>[] squareMap = new HashMap[9];
    public void solveSudoku(char[][] board) {
        for (int i = 0; i < 9; i++) {
            rowMap[i] = new HashMap<>();
            colMap[i] = new HashMap<>();
            squareMap[i] = new HashMap<>();
        }
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                char c = board[i][j];
                if (c != '.') {
                    rowMap[i].put(c, 1);
                    colMap[j].put(c, 1);
                    squareMap[i/3*3+j/3].put(c, 1);
                }
            }
        }
        solveSudoku(board, 0, 0);
    }
    public int solveSudoku(char[][] board, int i, int j) {
        int nextI, nextJ;
        if (i > 8) return 1;
        if (j == 8) {
            nextI = i+1;
            nextJ = 0;
        } else {
            nextI = i;
            nextJ = j+1;
        }
        char c = board[i][j];
        if (c == '.') {
            for (char k = '1'; k <= '9'; k++) {
                if (rowMap[i].getOrDefault(k, 0) == 0 && colMap[j].getOrDefault(k, 0) == 0 && squareMap[i/3*3+j/3].getOrDefault(k, 0) == 0) {
                    rowMap[i].put(k, 1);
                    colMap[j].put(k, 1);
                    squareMap[i/3*3+j/3].put(k, 1);
                    board[i][j] = k;
                    if (solveSudoku(board, nextI, nextJ) == 1) return 1;
                    rowMap[i].put(k, 0);
                    colMap[j].put(k, 0);
                    squareMap[i/3*3+j/3].put(k, 0);
                    board[i][j] = '.';
                }
            }
            return -1;
        } else {
            return solveSudoku(board, nextI, nextJ);
        }
    }
}
```

### 38 外观数列

方法一：递归

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public String countAndSay(int n) {
        if (n == 1) return "1";
        String prev = countAndSay(n-1);
        int length = prev.length();
        StringBuffer sb = new StringBuffer();
        int i = 0;
        int cnt;
        while(i < length) {
            cnt = 1;
            while (i+1 < length && prev.charAt(i+1) == prev.charAt(i)) {
                cnt++;
                i++;
            }
            sb.append((char)('0'+cnt));
            sb.append(prev.charAt(i));
            i++;
        }
        return sb.toString();
    }
}
```

### 114 二叉树展开为链表

方法一：分治

时间复杂度：O(n)

空间复杂度：O(log n)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public void flatten(TreeNode root) {
        if (root == null) return;
        flatten(root.left);
        TreeNode right = root.right;
        root.right = root.left;
        root.left = null;
        while (root.right != null) {
            root = root.right;
        }
        flatten(right);
        root.right = right;
    }
}
```

### 415 字符串相加

方法一：遍历一次

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    int m, n;
    public String addStrings(String num1, String num2) {
        StringBuffer sb = new StringBuffer();
        m = num1.length();
        n = num2.length();
        int i = 0;
        int nextBit = 0;
        while (i < m && i < n) {
            nextBit =  helper(sb, num1, num2, i, nextBit);
            i++;
        }
        while (i < m) {
            nextBit =helper(sb, num1, null, i, nextBit);
            i++;
        }
        while (i < n) {
            nextBit =  helper(sb, null, num2, i, nextBit);
            i++;
        }
        if (nextBit == 1) sb.insert(0, '1');
        return sb.toString();
    }
    public int helper(StringBuffer sb, String num1, String num2, int i, int nextBit) {
        int tmp1 = (num1 != null)?(int)(num1.charAt(m-1-i) - '0'): 0;
        int tmp2 = (num2 != null)?(int)(num2.charAt(n-1-i) - '0'): 0;
        int bit = (tmp1 + tmp2 + nextBit) % 10;
        nextBit = (tmp1 + tmp2 + nextBit) / 10;
        sb.insert(0, (char)(bit+'0'));
        return nextBit;
    }
}
```

### 632 最小区间

方法一：维护一个最小堆，一个`currArray`数组保存当前处理的每个列表的下标，最小堆比较的是列表中的值大小，并保存一个最大值。每次都从堆中取出最小值，然后那个最小值所在的数组往后移动一位加入到堆中。

时间复杂度：O(nk logk), n是所有列表平均长度

空间复杂度：O(k)

```java
class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        int ansLeft = 0, ansRight = Integer.MAX_VALUE;
        int k = nums.size();
        int[] currArray = new int[k];
        Comparator<Integer> comp = new Comparator<>() {
            public int compare(Integer index1, Integer index2) {
                return nums.get(index1).get(currArray[index1]) - nums.get(index2).get(currArray[index2]);
            }
        };
        Queue<Integer> queue = new PriorityQueue<>(comp);
        int maxValue = Integer.MIN_VALUE;
        for (int i = 0; i < k; i++) {
            queue.offer(i);
            maxValue = Math.max(maxValue, nums.get(i).get(currArray[i]));
        }
        while (true) {
            int minIndex = queue.poll();
            int minValue = nums.get(minIndex).get(currArray[minIndex]);
            if (maxValue - minValue < ansRight - ansLeft) {
                ansLeft = minValue;
                ansRight = maxValue;
            }
            currArray[minIndex]++;
            if (currArray[minIndex] ==  nums.get(minIndex).size()) break;
            queue.offer(minIndex);
            maxValue = Math.max(maxValue, nums.get(minIndex).get(currArray[minIndex]));
        }
        return new int[]{ansLeft, ansRight};
    }
}
```

### 100 相同的树

方法一：递归

n 为树结点个数

时间复杂度：O(n)

空间复杂度：O(log n)

```java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q== null) return true;
        if ((p == null && q != null) || (p !=null && q == null)) return false;
        if (p.val != q.val) return false;
        return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));
    }
}
```

### 207 课程表

方法一：DFS

m个结点n个边

时间复杂度：O(m+n)

空间复杂度：O(m+n)

```java
class Solution {
    int clock = 0;
    // 定义图上结点
    class Node {
        int val;
        Node next;
        Node (int val, Node next) {
            this.val = val;
            this.next = next;
        }
    }
    public boolean canFinish(int numCourses, int[][] prerequisites) {

        // 构建图
        Node[] Graph = new Node[numCourses];
        int[] isVisited = new int[numCourses];
        int[] prev = new int[numCourses];
        int[] post = new int[numCourses];
        for (int i = 0; i < numCourses; i++) {
            Graph[i] = new Node(i, null);
            prev[i] = -1;
            post[i] = -1;
        }
        for (int i = 0; i < prerequisites.length; i++) {
            Node tmp = new Node(prerequisites[i][0], Graph[prerequisites[i][1]].next);
            Graph[prerequisites[i][1]].next = tmp;
        }
        dfs(Graph, isVisited, prev, post);
        // 判断是否存在后向边
        for (int i = 0; i < numCourses; i++) {
            Node curr = Graph[i].next;
            while (curr != null) {
                if (prev[i] > prev[curr.val] && post[i] < post[curr.val]) return false;
                curr = curr.next;
            }
        }
        return true;
    }

    public void dfs(Node[] Graph, int[] isVisited, int[] prev, int[] post) {
        for (int i = 0; i < Graph.length; i++) {
            if (isVisited[i] == 0) explore(Graph, i, isVisited, prev, post);
        }
    }
    public void explore(Node[] Graph, int v, int[] isVisited, int[] prev, int[] post) {
        isVisited[v] = 1;
        prev[v] = clock;
        clock++;
        Node curr = Graph[v].next;
        while (curr != null) {
            if (isVisited[curr.val] == 0) explore(Graph, curr.val, isVisited, prev, post);
            curr = curr.next;
        }
        post[v] = clock;
        clock++;
    }
}
```

官方解法：

```java
class Solution {
    List<List<Integer>> edges;
    int[] visited;
    boolean valid = true;

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        edges = new ArrayList<List<Integer>>();
        for (int i = 0; i < numCourses; ++i) {
            edges.add(new ArrayList<Integer>());
        }
        visited = new int[numCourses];
        for (int[] info : prerequisites) {
            edges.get(info[1]).add(info[0]);
        }
        for (int i = 0; i < numCourses && valid; ++i) {
            if (visited[i] == 0) {
                dfs(i);
            }
        }
        return valid;
    }

    public void dfs(int u) {
        visited[u] = 1;
        for (int v: edges.get(u)) {
            if (visited[v] == 0) {
                dfs(v);
                if (!valid) {
                    return;
                }
            } else if (visited[v] == 1) {
                valid = false;
                return;
            }
        }
        visited[u] = 2;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/course-schedule/solution/ke-cheng-biao-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### 337 打家劫舍II

方法一：dfs+memo

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    HashMap<TreeNode, Integer> map = new HashMap<>();
    public int rob(TreeNode root) {
        return robMemo(root, map);
    }
    public int robMemo(TreeNode root, HashMap<TreeNode, Integer> map) {
        if (root == null) return 0;
        if (map.containsKey(root)) return map.get(root);
        int choice1 = root.val, choice2 = 0, choice3 = 0, choice4 = 0;
        int robLeft = robMemo(root.left, map);
        int robRight = robMemo(root.right, map); 
        if (root.left != null) {
            int robLeftLeft = robMemo(root.left.left, map), robLeftRight = robMemo(root.left.right, map);
            choice1 += robLeftLeft + robLeftRight;
            choice2 += robLeft;
            choice3 += robLeft;
            choice4 += robLeftLeft + robLeftRight; 
        }
        if (root.right != null) {
            int robRightLeft = robMemo(root.right.left, map), robRightRight = robMemo(root.right.right, map);
            choice1 += robRightLeft + robRightRight;
            choice2 += robRight;
            choice3 += robRightLeft + robRightRight;
            choice4 += robRight;
        }
        int ans = Math.max(Math.max(choice1, choice2), Math.max(choice3, choice4));
        map.put(root, ans);
        return ans;
    }
}
```

也可以用动态规划

### 99 恢复二叉搜索树

方法一：dfs+HashMap

对每个结点维护当前结点左右子树（包含当前结点）的最小值对应的结点和最大值对应的结点。

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    HashMap<TreeNode, TreeNode> minMap = new HashMap<>();
    HashMap<TreeNode, TreeNode> maxMap = new HashMap<>();
    public void recoverTree(TreeNode root) {
        dfs(root);
        helper(root);
    }
    public void dfs(TreeNode node) {
        if (node == null) return;
        dfs(node.left);
        dfs(node.right);
        TreeNode leftMaxNode = maxMap.getOrDefault(node.left, null);
        TreeNode rightMaxNode = maxMap.getOrDefault(node.right, null);
        TreeNode leftMinNode = minMap.getOrDefault(node.left, null);
        TreeNode rightMinNode = minMap.getOrDefault(node.right, null);
        maxMap.put(node, node);
        minMap.put(node, node);
        if (leftMaxNode != null) {
            TreeNode tmpMax = maxMap.get(node);
            if (leftMaxNode.val > tmpMax.val) maxMap.put(node, leftMaxNode);
        }
        if (leftMinNode != null) {
            TreeNode tmpMin = minMap.get(node);
            if (leftMinNode.val < tmpMin.val) minMap.put(node, leftMinNode);
        }
        if (rightMaxNode != null) {
            TreeNode tmpMax = maxMap.get(node);
            if (rightMaxNode.val > tmpMax.val) maxMap.put(node, rightMaxNode);
        }
        if (rightMinNode != null) {
            TreeNode tmpMin = minMap.get(node);
            if (rightMinNode.val < tmpMin.val) minMap.put(node, rightMinNode);
        }
    }
    public void helper(TreeNode node) {
        if (node == null) return;
        TreeNode leftMaxNode = maxMap.getOrDefault(node.left, null);
        TreeNode rightMinNode = minMap.getOrDefault(node.right, null);
        int tmp = node.val;
        if (leftMaxNode != null && rightMinNode == null) {
            if (node.val < leftMaxNode.val) {
                node.val = leftMaxNode.val;
                leftMaxNode.val = tmp;
                return;
            }
        } else if (rightMinNode != null && leftMaxNode == null) {
            if (node.val > rightMinNode.val) {
                node.val = rightMinNode.val;
                rightMinNode.val = tmp;
                return;
            }
        } else if (leftMaxNode != null && rightMinNode != null) {
            if (node.val < leftMaxNode.val && node.val > rightMinNode.val) {
                int tmpp = leftMaxNode.val;
                leftMaxNode.val = rightMinNode.val;
                rightMinNode.val = tmpp;
                return;
            } else if (node.val < leftMaxNode.val && node.val < rightMinNode.val) {
                node.val = leftMaxNode.val;
                leftMaxNode.val = tmp;
                return;
            } else if (node.val > leftMaxNode.val && node.val > rightMinNode.val) {
                node.val = rightMinNode.val;
                rightMinNode.val = tmp;
                return;
            }
        }
        helper(node.left);
        helper(node.right);
    }
}
```

方法二：中序遍历

```java
class Solution {
    public void recoverTree(TreeNode root) {
        List<TreeNode> inOrderList = new ArrayList<>();
        inOrder(root, inOrderList);
        TreeNode[] needSwap = new TreeNode[3];
        int k = 0;
        for (int i = 0; i < inOrderList.size()-1; i++) {
            TreeNode curr = inOrderList.get(i);
            TreeNode next = inOrderList.get(i+1);
            if (curr.val > next.val) {
                if (k == 0) {
                    needSwap[k++] = curr;
                    needSwap[k] = next;
                } else {
                    needSwap[k++] = next;
                    needSwap[k] = curr;
                }
            }
        }
        int tmp = needSwap[0].val;
        needSwap[0].val = needSwap[1].val;
        needSwap[1].val = tmp;
    }
    public void inOrder(TreeNode node, List<TreeNode> inOrderList) {
        if (node == null) return;
        inOrder(node.left, inOrderList);
        inOrderList.add(node);
        inOrder(node.right, inOrderList);
    }
}
```

### 696 计数二进制子串

方法一：一次遍历

时间复杂度：O(n)

空间复杂度：O(1)

```java
class Solution {
    public int countBinarySubstrings(String s) {
        int ans = 0;
        int i = 0;
        while (i < s.length()) {
            int k = i;
            int first = 1;
            while (k+1 < s.length() && s.charAt(k+1) == s.charAt(k)) {
                first++;
                k++;
            }
            if (k == s.length() - 1) break;
            int last = 1;
            k++;
            while (k+1 < s.length() && s.charAt(k+1) == s.charAt(k)) {
                last++;
                k++;
            }
            ans += Math.min(first, last);
            i += first;
        }
        return ans;
    }
}
```

### 93 复原IP地址

方法一：递归

时间复杂度：O(3^4 * |s|)

空间复杂度：O(|s|)

```java
class Solution {
    List<String> ans = new ArrayList<>();
    public List<String> restoreIpAddresses(String s) {
        StringBuffer curr = new StringBuffer();
        helper(s, 0, curr, 0);
        return ans;
    }
    public void helper(String s, int index, StringBuffer curr, int pointNum) {
        if (pointNum > 3) return;
        if (index == s.length()) {
            if (pointNum == 3) ans.add(curr.toString());
            return;
        }
        int number = 0;
        int k = 0;
        int zeroFirst = 0;
        while (true) {
            char tmp = s.charAt(index);
            if (k == 0 && tmp == '0') {
                zeroFirst = 1;
            }
            number = number * 10 + (int)(tmp - '0');
            if (number > 255) break;
            curr.append(tmp);
            if (index == s.length() - 1) {
                helper(s, ++index, curr, pointNum);
                return;
            }
            curr.append('.');
            int currLength = curr.length();
            helper(s, ++index, curr, pointNum+1);
            curr.delete(currLength-1 , curr.length());
            if (zeroFirst == 1) break;
            k++;
        }
    }
}
```

### 336 回文对

方法一：枚举前缀和后缀

假设有n个单词，单词的平均长度为m

时间复杂度：O(nm^2)

空间复杂度：O(n*m)

```java
class Solution {
    public List<List<Integer>> palindromePairs(String[] words) {
        HashMap<String, Integer> map = new HashMap<>();
        List<List<Integer>> ans = new ArrayList<>();
        // 将所有字符串的倒序加入到map中
        for (int k = 0; k < words.length; k++) {
            String word = words[k];
            StringBuffer sb = new StringBuffer();
            int wordLength = word.length();
            for (int i = 0; i < wordLength; i++) {
                sb.append(word.charAt(wordLength-i-1));
            }
            map.put(sb.toString(), k);
        }
        for (int k = 0; k < words.length; k++) {
            String word = words[k];
            int i = 0;
            int wordLength = word.length();
            List<Integer> tmp;
            int left = 0, right = 0;
            while (i <= wordLength) {
                if (isPalindrome(word.substring(0, i))) {
                    left = map.getOrDefault(word.substring(i, wordLength), -1);
                    if (left != -1 && left != k) {
                        tmp = new ArrayList<>();
                        tmp.add(left);
                        tmp.add(k);
                        ans.add(tmp);
                    }
                }
                if (isPalindrome(word.substring(wordLength-i, wordLength))) {
                    right = map.getOrDefault(word.substring(0, wordLength-i), -1);
                    if (right != -1 && right != k && wordLength != words[right].length()) {
                        tmp = new ArrayList<>();
                        tmp.add(k);
                        tmp.add(right);
                        ans.add(tmp);
                    }
                }
                i++;
            }
        }
        return ans;
    }
    public boolean isPalindrome(String word) {
        int wordLength = word.length();
        for (int i = 0; i < wordLength/2; i++) {
            if (word.charAt(i) != word.charAt(wordLength-i-1)) return false;
        }
        return true;
    }
}
```

### 130 被围绕的区域

方法一：dfs，从每个边界处的'O'出发

时间复杂度：O(mn)

空间复杂度：O(mn)

```java
class Solution {
    int[] x = new int[]{-1, 1, 0, 0};
    int[] y = new int[]{0, 0, -1, 1};
    int m, n;
    public void solve(char[][] board) {
        m = board.length;
        if (m == 0) return;
        n = board[0].length;
        int[][] isVisited = new int[m][n];
        for (int j = 0; j < n; j++) {
            if (check(board, isVisited, 0, j)) dfs(board, isVisited, 0, j);
            if (check(board, isVisited, m-1, j)) dfs(board, isVisited, m-1, j);
        }
        for (int i = 1; i < m-1; i++) {
            if (check(board, isVisited, i, 0)) dfs(board, isVisited, i, 0);
            if (check(board, isVisited, i, n-1)) dfs(board, isVisited, i, n-1);
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (check(board, isVisited, i, j)) board[i][j] = 'X';
            }
        }
    }
    public void dfs(char[][] board, int[][] isVisited, int i, int j) {
        isVisited[i][j] = 1;
        for (int k = 0; k < 4; k++) {
            int newI = i + x[k];
            int newJ = j + y[k];
            if (newI >= 0 && newI < m && newJ >= 0 && newJ < n) {
                if (check(board, isVisited, newI, newJ)) dfs(board, isVisited, newI, newJ);
            }
        }
    }
    public boolean check(char[][] board, int[][] isVisited, int i, int j) {
        return isVisited[i][j] == 0 && board[i][j] == 'O';
    }
}
```

### 133 克隆图

方法一：bfs

时间复杂度：O(n)

空间复杂度：O(n)

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> neighbors;
    
    public Node() {
        val = 0;
        neighbors = new ArrayList<Node>();
    }
    
    public Node(int _val) {
        val = _val;
        neighbors = new ArrayList<Node>();
    }
    
    public Node(int _val, ArrayList<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}
*/
class Solution {
    public Node cloneGraph(Node node) {
        if (node == null) return null;
        HashMap<Integer, Node> map = new HashMap<>();
        Queue<Node> queueCopy = new LinkedList<>();
        Queue<Node> queueOrigin = new LinkedList<>();
        queueOrigin.offer(node);
        Node copyStart = new Node(node.val);
        queueCopy.offer(copyStart);
        map.put(1, copyStart);
        while (queueOrigin.size() != 0) {
            Node originNode = queueOrigin.poll();
            Node copyNode = queueCopy.poll();
            for (Node neighbor: originNode.neighbors) {
                Node tmp = map.getOrDefault(neighbor.val, null);
                if (tmp == null) {
                    tmp = new Node(neighbor.val);
                    map.put(tmp.val, tmp);
                    queueCopy.offer(tmp);
                    queueOrigin.offer(neighbor);
                }
                copyNode.neighbors.add(tmp);
            }
        }
        return copyStart;
    }
}
```

删减

```java
class Solution {
    public Node cloneGraph(Node node) {
        if (node == null) return null;
        HashMap<Integer, Node> map = new HashMap<>();
        Queue<Node> queueOrigin = new LinkedList<>();
        queueOrigin.offer(node);
        Node copyStart = new Node(node.val);
        map.put(1, copyStart);
        while (queueOrigin.size() != 0) {
            Node originNode = queueOrigin.poll();
            Node copyNode = map.get(originNode.val);
            for (Node neighbor: originNode.neighbors) {
                Node tmp = map.getOrDefault(neighbor.val, null);
                if (tmp == null) {
                    tmp = new Node(neighbor.val);
                    map.put(tmp.val, tmp);
                    queueOrigin.offer(neighbor);
                }
                copyNode.neighbors.add(tmp);
            }
        }
        return copyStart;
    }
}
```

### 43 字符串相乘

方法一：每一位相乘，然后相加

num1长度为m，num2长度为2

时间复杂度：O(mn+n^2)

空间复杂度：O(m+n)

```java
class Solution {
    public String multiply(String num1, String num2) {
        if (num1.equals("0") || num2.equals("0")) return "0";
        StringBuffer ans = new StringBuffer();
        int k = 0;
        for (int i = num2.length()-1; i >= 0; i--) {
            int bit = (int)(num2.charAt(i) - '0');
            StringBuffer tmp = multiplyOneBit(num1, bit);
            for (int j = 1; j <= k; j++) {
                tmp.append('0');
            }
            ans = add(ans, tmp);
            k++;
        }
        return ans.toString();
    }
    public StringBuffer add(StringBuffer num1, StringBuffer num2) {
        StringBuffer ret = new StringBuffer();
        int m = num1.length();
        int n = num2.length();
        int i = 0;
        int nextFlag = 0;
        int bit1, bit2;
        while (i < m || i < n) {
            bit1 = (i < m)?num1.charAt(m-i-1) - '0': 0;
            bit2 = (i < n)?num2.charAt(n-i-1) - '0': 0;
            int curr = bit1 + bit2 + nextFlag;
            int currBit = curr % 10;
            nextFlag = curr / 10;
            ret.insert(0, (char)(currBit + '0'));
            i++;
        }
        if (nextFlag == 1) ret.insert(0, '1');
        return ret;
    }
    public StringBuffer multiplyOneBit(String num1, int bit) {
        StringBuffer ret = new StringBuffer();
        int nextFlag = 0;
        for (int i = num1.length()-1; i >= 0; i--) {
            int curr = (int)(num1.charAt(i) - '0') * bit + nextFlag;
            int currBit = curr % 10;
            nextFlag = curr / 10;
            ret.insert(0, (char)(currBit+'0'));
        }
        if (nextFlag != 0) ret.insert(0, (char)(nextFlag+'0')); 
        return ret;
    }
}
```

### 733 图像渲染

方法一：dfs

时间复杂度：O(mn)

空间复杂度：O(mn)

```java
class Solution {
    int[] dx = {-1, 1, 0, 0};
    int[] dy = {0, 0, 1, -1};
    int m, n;
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        int originColor = image[sr][sc];
        m = image.length;
        n = image[0].length;
        image[sr][sc] = newColor;
        if (newColor != originColor) helper(image, sr, sc, originColor, newColor);
        return image;
    }
    public void helper(int[][] image, int sr, int sc, int originColor, int newColor) {
        for (int i = 0; i < 4; i++) {
            int newX = sr + dx[i];
            int newY = sc + dy[i];
            if (newX >= 0 && newX < m && newY >=0 && newY < n && image[newX][newY] == originColor) {
                image[newX][newY] = newColor;
                helper(image, newX, newY, originColor, newColor);
            }
        }
    }
}
```

### 110 平衡二叉树

方法一：递归

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        int rootHeight = getHeight(root);
        if (rootHeight == -1) {
            return false;
        } else {
            return true;
        }
    }
    public int getHeight(TreeNode node) {
        if (node == null) return 0;
        int leftHeight = getHeight(node.left);
        int rightHeight = getHeight(node.right);
        if (leftHeight == -1 || rightHeight == -1) {
            return -1;
        } else {
            if (Math.abs(leftHeight - rightHeight) > 1) {
                return -1;
            } else {
                return Math.max(leftHeight, rightHeight) + 1;
            }
        }
    }
}
```

### 109 有序链表转换二叉搜索树

方法一：分治+快慢指针

时间复杂度：O(n logn)

空间复杂度：O(logn)

```java
class Solution {
    public TreeNode sortedListToBST(ListNode head) {
        return buildTree(head, null);
    }
    public TreeNode buildTree(ListNode head, ListNode tail) {
        if (head == tail) return null;
        ListNode middle = findMidlle(head, tail);
        TreeNode root = new TreeNode(middle.val, null, null);
        root.left = buildTree(head, middle);;
        root.right = buildTree(middle.next, tail);
        return root;
    }
    public ListNode findMidlle(ListNode left, ListNode right) {
        ListNode fast = left;
        ListNode slow = left;
        while (fast != right && fast.next != right) {
            fast = fast.next;
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}
```

方法二：分治+中序遍历 todo

### 529 扫雷游戏

方法一：dfs

时间复杂度：O(mn)

空间复杂度：O(mn)

```java
class Solution {
    int[] dx = {-1, 1, 0, 0, -1, -1, 1, 1};
    int[] dy = {0, 0, 1, -1, -1, 1, -1, 1};
    int m, n;
    public char[][] updateBoard(char[][] board, int[] click) {
        m = board.length;
        n = board[0].length;
        helper(board, click);
        return board;
    }
    public void helper(char[][] board, int[] click) {
        int x = click[0], y = click[1];
        if (board[x][y] == 'M') {
            board[x][y] = 'X';
            return;
        } else if (board[x][y] == 'E') {
            int numM = 0;
            for (int i = 0; i < 8; i++) {
                int newX = x + dx[i], newY = y + dy[i];
                if (newX >= 0 && newX < m && newY >= 0 && newY < n && board[newX][newY] == 'M') numM++;
            }
            if (numM == 0) {
                board[x][y] = 'B';
                for (int i = 0; i < 8; i++) {
                    int newX = x + dx[i], newY = y + dy[i];
                    if (newX >= 0 && newX < m && newY >= 0 && newY < n && board[newX][newY] == 'E') helper(board, new int[]{x+dx[i], y+dy[i]});
                }
            } else {
                board[x][y] = (char)('0' + numM);
            }
        }
    }
}
```

### 111 二叉树的最小深度

方法一：递归

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        if (root.left == null && root.right == null) return 1;
        int ans = Integer.MAX_VALUE;
        if (root.left != null) ans = Math.min(ans, minDepth(root.left));
        if (root.right != null) ans = Math.min(ans, minDepth(root.right));
        return ans + 1;
    }
}
```

### 201 数字范围按位与

方法一：暴力求解

时间复杂度：O(n)

空间复杂度：O(1)

```java
class Solution {
    public int rangeBitwiseAnd(int m, int n) {
        int ans = m;
        if (m == Integer.MAX_VALUE) return ans;
        for (int i = m+1; i <= n; i++) {
            if (ans == 0) return 0;
            ans = ans & i;
            if (i == Integer.MAX_VALUE) break;
        }
        return ans;
    }
}
```

方法二：位移

问题等同于求m和n的最长公共前缀

```java
class Solution {
    public int rangeBitwiseAnd(int m, int n) {
        int k = 0;
        while (m != n) {
            m = m >> 1;
            n = n >> 1;
            k++;
        }
        return (m << k);
    }
}
```

### 647 回文子串

方法一：动态规划

时间复杂度：O(n^2)

空间复杂度：O(n^2)

```java
class Solution {
    public int countSubstrings(String s) {
        int ans = 0;
        int n = s.length();
        int[][] dp = new int[n][n];
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
            ans++;
        }
        for (int i = n-1; i >= 0; i--) {
            for (int j = i+1; j <= n-1; j++) {
                if (j == i+1) {
                    if (s.charAt(j) == s.charAt(i)) {
                        dp[i][j] = 1;
                        ans++;
                    } else {
                        dp[i][j] = 0;
                    }
                } else {
                    if (s.charAt(j) == s.charAt(i) && dp[i+1][j-1] == 1) {
                        dp[i][j] = 1;
                        ans++;
                    } else {
                        dp[i][j] = 0;
                    }
                }
            }
        }
        return ans;
    }
}
```

方法二：从中心扩展

时间复杂度：O(n^2)

空间复杂度：O(1)

方法三：manacher

时间复杂度：O(n)

空间复杂度：O(n)

### 459 重复的子字符串

方法一：枚举每个以第一个字符为开头的子字符串

时间复杂度：O(n^2)

空间复杂度：O(1)

```java
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        int firstChar = s.charAt(0);
        int i = 1;
        int n = s.length();
        int flag = 1;
        while (i <= n / 2) {
            while (s.charAt(i) != firstChar) {
                i++;
                if (i == n) return false;
            }
            int patternLength = i;
            if (n % patternLength != 0) {
                i++;
                continue;
            }
            String pattern = s.substring(0, patternLength);
            for (int k = i; k < n; k += patternLength) {
                if (!pattern.equals(s.substring(k, k+patternLength))) {
                    flag = 0;
                    break;
                }
            }
            if (flag == 1) {
                return true;
            } else {
                flag = 1;
                i++;
            }
        }
        return false;
    }
}
```

### 491 递增子序列

方法一：dfs

时间复杂度：

空间复杂度：

```java
class Solution {
    HashMap<List<Integer>, Integer> map = new HashMap<>();
    List<List<Integer>> ret = new LinkedList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        if (nums.length != 0) findSubsequences(nums, 0);
        return ret;
    }
    public void findSubsequences(int[] nums, int i) {
        if (i == nums.length - 1) return;
        findSubsequences(nums, i+1);
        int subSequencesLength = ret.size();
        for (int k = i+1; k < nums.length; k++) {
            if (nums[k] >= nums[i]) {
                List<Integer> tmp = new LinkedList<>();
                tmp.add(nums[i]);
                tmp.add(nums[k]);
                if (!map.containsKey(tmp)) {
                    ret.add(tmp);
                    map.put(tmp, 0);
                }
            }
        }
        for (int k = 0; k < subSequencesLength; k++) {
            List<Integer> seq = ret.get(k);
            if (nums[i] <= seq.get(0)) {
                List<Integer> tmp = new LinkedList<>();
                tmp.add(nums[i]);
                for (int e: seq) {
                    tmp.add(e);
                }
                if (!map.containsKey(tmp)) {
                    ret.add(tmp);
                    map.put(tmp, 0);
                }
            }
        }
    }
}
```

方法二：dfs+剪枝

时间复杂度：O(2^n *n)

空间复杂度：O(n)

```java
class Solution {
    List<Integer> tmp = new ArrayList<Integer>();
    List<List<Integer>> ans = new ArrayList<List<Integer>>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        helper(0, Integer.MIN_VALUE, nums);
        return ans;
    }
    public void helper(int curr, int last, int[] nums) {
        if (curr == nums.length) {
            if (tmp.size() >= 2) ans.add(new ArrayList<Integer>(tmp));
            return;
        }
        if (nums[curr] >= last) {
            tmp.add(nums[curr]);
            helper(curr+1, nums[curr], nums);
            tmp.remove(tmp.size()-1);
        }
        if (nums[curr] != last) {
            helper(curr+1, last, nums);
        }
    } 
}
```

### 39 组合总和

方法一：递归

时间复杂度：O(2^n)

空间复杂度：O(n)

```java
class Solution {
    List<Integer> tmp = new LinkedList<>();
    List<List<Integer>> ans = new LinkedList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        helper(candidates, target, 0);
        return ans;
    }
    public void helper(int[] candidates, int target, int k) {
        if (target == 0)  {
            ans.add(new LinkedList<Integer>(tmp));
            return;
        }
        if (candidates[0] > target) {
            return;
        }
        for (int i = k; i < candidates.length; i++) {
            if (candidates[i] <= target) {
                tmp.add(candidates[i]);
                helper(candidates, target-candidates[i], i);
                tmp.remove(tmp.size()-1);
            }
        }
    }
}
```

### 40 组合总和II

方法一：递归

时间复杂度：O(2^n)

空间复杂度：O(n)

```java
class Solution {
    List<Integer> tmp = new LinkedList<>();
    List<List<Integer>> ans = new LinkedList<>();
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        helper(candidates, target, 0);
        return ans;
    }
    public void helper(int[] candidates, int target, int k) {
        if (target == 0)  {
            ans.add(new LinkedList<Integer>( tmp));
            return;
        }
        if (candidates[0] > target) {
            return;
        }
        for (int i = k; i < candidates.length; i++) {
            if (candidates[i] <= target) {
                if (i != k && candidates[i] == candidates[i-1] ) continue;
                tmp.add(candidates[i]);
                helper(candidates, target-candidates[i], i+1);
                tmp.remove(tmp.size()-1);
            }
        }
    }
}
```

### 546 移除盒子

方法一：递归+memo

时间复杂度：O(n^4)

空间复杂度：O(n^3)

```java
class Solution {
    int[][][] dp;
    public int removeBoxes(int[] boxes) {
        int n = boxes.length;
        dp = new int[n][n][n];
        return helper(boxes, 0, n-1, 0);
    }
    public int helper(int[] boxes, int l, int r, int num) {
        if (l > r) return 0;
        if (dp[l][r][num] != 0) return dp[l][r][num];
        int k = 0;
        int e = boxes[r];
        int rOrigin = r, numOrigin = num;
        while (r >= l && boxes[r] == e) {
            r--;
            k++;
        }
        num += k;
        int max = helper(boxes, l, r, 0) + (int)Math.pow(num, 2);
        for (int i = l; i < r; i++) {
            if (boxes[i] == e) {
                max = Math.max(max, helper(boxes, l, i, num) + helper(boxes, i+1, r, 0));
            }
        }
        dp[l][rOrigin][numOrigin] = max;
        return max;
    }
}
```

### 332 重新安排行程

方法一：dfs

首先要构建图，这里将城市字符串和一个整数ID对应，方便处理，图的每个节点的相邻节点用List存储。

假设有n个节点，m条边, 每个节点最多有K个边

时间复杂度：O(mK)

空间复杂度：O(m+n)

```java
class Solution {
    HashMap<String, Integer> str2int;
    String[] int2str;
    List<Integer>[] graph;
    int nodeNum;
    int edgeNum;
    public List<String> findItinerary(List<List<String>> tickets) {
        str2int = new HashMap<>();
        int2str = new String[tickets.size()*2];
        graph = new List[tickets.size()*2];
        for (int i = 0; i < tickets.size()*2; i++) {
            graph[i] = new LinkedList<Integer>();
        }
        nodeNum = 0;
        edgeNum = 0;
        for (List<String> tmp: tickets) {
            edgeNum++;
            for (int i = 0; i < 2; i++) {
                String city = tmp.get(i);
                if (!str2int.containsKey(city)) {
                    str2int.put(city, nodeNum);
                    int2str[nodeNum] = city;
                    nodeNum++;
                }
            }
            String from = tmp.get(0);
            String to = tmp.get(1);
            int fromId = str2int.get(from);
            int toId = str2int.get(to);
            int i = 0;
            while (i < graph[fromId].size() && to.compareTo(int2str[graph[fromId].get(i)]) > 0) {
                i++;
            }
            graph[fromId].add(i, toId);
        }
        int JFKID = str2int.get("JFK");
        List<String> ans = new LinkedList<>();
        ans.add("JFK");
        dfs(JFKID, ans, 0);
        return ans;
    }
    public int dfs(int id, List<String> ans, int visitedEdgeNum) {
        if (graph[id].size() == 0) {
            if (visitedEdgeNum == edgeNum) {
                return 1;
            } else {
                return 0;
            }
        }
        int length = graph[id].size();
        for (int i = 0; i < length; i++) {
            int toId = graph[id].get(i);
            String to = int2str[toId];
            ans.add(to);
            graph[id].remove(i);
            int flag = dfs(toId, ans, visitedEdgeNum+1);
            if (flag == 1) {
                return 1;
            } else {
                graph[id].add(i, toId);
                ans.remove(ans.size()-1);
            }
        }
        return 0;
    }
} 
```

方法二：使用优先队列

假设有m条边

时间复杂度：O(m*logm)

空间复杂度：O(m)

```java
class Solution {
    HashMap<String, PriorityQueue<String>> map = new HashMap<>();
    public List<String> findItinerary(List<List<String>> tickets) {
        List<String> ans = new LinkedList<>();
        for (List<String> tmp: tickets) {
            if (!map.containsKey(tmp.get(0))) {
                map.put(tmp.get(0), new PriorityQueue<String>());
            }
            map.get(tmp.get(0)).offer(tmp.get(1));
        }
        dfs("JFK", ans);
        Collections.reverse(ans);
        return ans;
    }
    public void dfs(String city, List<String> ans) {
        while (map.containsKey(city) && map.get(city).size() != 0) {
            dfs(map.get(city).poll(), ans);
        }
        ans.add(city);
    }
}
```



### 657 机器人能否返回原点

方法一：看位置

时间复杂度：O(n)

空间复杂度：O(1)

```java
class Solution {
    int[] dx = {1, -1, 0, 0};
    int[] dy = {0, 0, 1, -1};
    public boolean judgeCircle(String moves) {
        int[] pos = new int[2];
        for (int i = 0; i < moves.length(); i++) {
            int id = getId(moves.charAt(i));
            pos[0] += dx[id];
            pos[1] += dy[id];
        }
        if (pos[0] == 0 && pos[1] == 0) {
            return true;
        } else {
            return false;
        }
    }
    public int getId(char c) {
        switch (c) {
            case 'R': return 0;
            case 'L': return 1;
            case 'U': return 2;
            case 'D': return 3;
            default: return -1;
        }
    }
}
```

### 557 反转字符串中的单词III

方法一：StringBuffer

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public String reverseWords(String s) {
        StringBuffer ans = new StringBuffer();
        int i = 0;
        int n = s.length();
        while (i < n) {
            while (s.charAt(i) == ' ') {
                i++;
                ans.append(' ');
            }
            StringBuffer tmp = new StringBuffer();
            while (i < n && s.charAt(i) != ' ') {
                tmp.insert(0, s.charAt(i));
                i++;
            }
            ans.append(tmp);
        }
        return ans.toString();
    }
}
```

### 5500 乘积为正数的最长子数组长度

方法一：动态规划 (超时)

`dp[i][j]`表示i到j之间的数乘积为正的话为1，乘积为负的话为-1。 

时间复杂度：O(n^2)

空间复杂度：O(n)

```java
class Solution {
    public int getMaxLen(int[] nums) {
        int ans = 0;
        int n = nums.length;
        int[] next = new int[n];
        int[] prev = new int[n];
        for (int i = n-1; i >= 0; i--) {
            for (int j = n-1; j >= 0; j--) {
                if (i == j) {
                    if (nums[i] > 0) {
                        next[j] = 1;
                        ans = Math.max(ans, 1);
                    }    
                    if (nums[i] < 0) next[j] = -1;
                }
                if (j >= i+1) {
                    int tmp = 0;
                    if (nums[i] > 0 && nums[j] > 0) tmp = 1;
                    if (nums[i] > 0 && nums[j] < 0) tmp = -1;
                    if (nums[i] < 0 && nums[j] < 0) tmp = 1;
                    if (nums[i] < 0 && nums[j] > 0) tmp = -1;
                    if (j == i+1) prev[j-1] = 1;
                    if ((prev[j-1] > 0 && tmp > 0) || (prev[j-1] < 0 && tmp < 0) ) {
                        next[j] = 1;
                        ans = Math.max(ans, j-i+1);
                    } else if (tmp == 0 || prev[j-1] == 0) {
                        next[j] = 0;
                    } else {
                        next[j] = -1;
                    }
                }
                prev[j] = next[j];
            }
        }
        return ans;
    }
}
```

方法二：动态规划

`pos[i]` 表示以i为结尾的乘积为正的数组长度。

`neg[i]`表示以i为结尾的乘积为负的数组长度。

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public int getMaxLen(int[] nums) {
        int n = nums.length;
        int[] pos = new int[n];
        int[] neg = new int[n];
        int ans = 0;
        if (nums[0] > 0) {
            pos[0] = 1;
            ans = Math.max(ans, pos[0]);
        } else if (nums[0] < 0) {
            neg[0] = 1;
        }
        for (int i = 1; i < n; i++) {
            if (nums[i] == 0) {
                pos[i] = 0;
                neg[i] = 0;
            } else if (nums[i] > 0) {
                pos[i] = pos[i-1] + 1;
                neg[i] = (neg[i-1] != 0)?neg[i-1] + 1: 0;
            } else {
                pos[i] = (neg[i-1] != 0)?neg[i-1] + 1: 0;
                neg[i] = pos[i-1] + 1; 
            }
            ans = Math.max(ans, pos[i]);
        }
        return ans;
    }
}
```

### 841 钥匙和房间

方法一：dfs

用一个isVisited数组来判断当前房间是否被访问过。

假设有n个房间，每个房间有最多有K把钥匙。

时间复杂度：O(nk)

空间复杂度：O(n)

```java
class Solution {
    int[] isVisited;
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        isVisited = new int[rooms.size()];
        dfs(rooms, 0);
        for (int i = 0; i < rooms.size(); i++) {
            if (isVisited[i] == 0) return false;
        }
        return true;
    }
    public void dfs(List<List<Integer>> rooms, int index) {
        isVisited[index] = 1;
        List<Integer> tmp = rooms.get(index);
        for (int i = 0; i < tmp.size(); i++) {
            int nextRoom = tmp.get(i);
            if (isVisited[nextRoom] == 0) {
                dfs(rooms, nextRoom);
            }
        }
    }
}
```

### 5501 使陆地分离的最少天数

方法一：dfs。

先判断一次整个图中的岛屿是否是连通的，如果不连通，返回0；然后遍历，将每个岛屿变为海洋，看其是否连通，如果不连通，返回1。如果遍历完所有岛屿的话，返回2。

时间复杂度：O(m^2 n^2)

空间复杂度：O(mn)

```java
class Solution {
    int[] dx = {-1, 1, 0, 0};
    int[] dy = {0, 0, 1, -1};
    int m, n;
    public int minDays(int[][] grid) {
        m = grid.length;
        n = grid[0].length;
        // check if grid is connected
        if (!check(grid)) return 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] != 0) {
                    grid[i][j] = 0;
                    if (!check(grid)) return 1;
                    grid[i][j] = 1;
                }
            }
        }
        return 2;
    }
    public boolean check(int[][] grid) {
        int cnt = 0;
        int x = 0, y = 0;
        int[][] isVisited = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) continue;
                cnt++;
                x = i;
                y = j;
            }
        }
        if (dfs(grid, x, y, isVisited) != cnt) return false;
        return true;
    }
    public int dfs(int[][] grid, int i, int j, int[][] isVisited) {
        isVisited[i][j] = 1;
        int ret = 1;
        for (int k = 0; k < 4; k++) {
            int newI = i + dx[k];
            int newJ = j + dy[k];
            if (newI >= 0 && newI < m && newJ >= 0 && newJ < n && grid[newI][newJ] == 1) {
                if (isVisited[newI][newJ] == 0) ret += dfs(grid, newI, newJ, isVisited);
            }
        }
        return ret;
    }
}
```

方法二：bfs

时间空间复杂度同上

```java
class Solution {
    int[] dx = {-1, 1, 0, 0};
    int[] dy = {0, 0, 1, -1};
    int m, n;
    public int minDays(int[][] grid) {
        m = grid.length;
        n = grid[0].length;
        // check if grid is connected
        if (!check(grid)) return 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] != 0) {
                    grid[i][j] = 0;
                    if (!check(grid)) return 1;
                    grid[i][j] = 1;
                }
            }
        }
        return 2;
    }
    public boolean check(int[][] grid) {
        int cnt = 0;
        int x = 0, y = 0;
        int[][] isVisited = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) continue;
                cnt++;
                x = i;
                y = j;
            }
        }
        int connectedNum = 0;
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{x, y});
        while (queue.size() != 0) {
            int[] tmp = queue.poll();
            if (isVisited[tmp[0]][tmp[1]] == 1) continue;
            isVisited[tmp[0]][tmp[1]] = 1;
            connectedNum++;
            for (int k = 0; k < 4; k++) {
                int nx = tmp[0] + dx[k];
                int ny = tmp[1] + dy[k];
                if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == 1) {
                    if (isVisited[nx][ny] == 0) {
                        queue.offer(new int[]{nx, ny});
                    }
                }
            }
        }
        if (connectedNum != cnt) return false;
        return true;
    }
}
```

### 486 预测赢家

方法一： 动态规划

`dp[i][j]` 表示在i-j范围内先手可以获得的最大分数

时间复杂度：O(n^2)

空间复杂度：O(n^2)

```java
class Solution {
    public boolean PredictTheWinner(int[] nums) {
        int n = nums.length;
        int[][] dp = new int[n][n];
        int[][] sum = new int[n][n];
        for (int i = n-1; i >= 0; i--) {
            for (int j = n-1; j >= i; j--) {
                if (j == i) sum[i][j] = nums[i];
                if (j > i) sum[i][j] = sum[i+1][j] + nums[i];
            }
        }
        for (int i = n-1; i >= 0; i--) {
            for (int j = i; j < n; j++) {
                if (j == i) dp[i][j] = nums[i];
                if (j > i) dp[i][j] = sum[i][j] - Math.min(dp[i+1][j], dp[i][j-1]);
            }
        }
        if (dp[0][n-1] >= sum[0][n-1] - dp[0][n-1]) return true;
        return false;
    }
}

```

### 剑指offer 20 

方法一：有限自动机

时间复杂度：O(N)

空间复杂度：O(1)

```java
class Solution {
    class Automatation {
        String START = "start";
        String SIGNED = "signed";
        String INTEGER = "integer";
        String HALFDECIMAL = "halfdecimal";
        String FALSE = "false";
        String TRUE = "true";
        String HALFSCIENCE = "halfscience";
        String HALFSIGNEDSCIENCE = "halfsignedscience";
        String DECIMAL = "decimal";
        String SCIENCE = "science";
        String POINT = "point";
        boolean ans = false;
        String state = START;
        HashMap<String, String[]> map;
        public Automatation() {
            map = new HashMap<>();
            map.put(START, new String[]{START, POINT, FALSE, INTEGER, SIGNED, FALSE});
            map.put(POINT, new String[]{FALSE, FALSE, FALSE, DECIMAL, FALSE, FALSE});
            map.put(SIGNED, new String[]{FALSE, POINT, FALSE, INTEGER, FALSE, FALSE});
            map.put(INTEGER, new String[]{TRUE, HALFDECIMAL, HALFSCIENCE, INTEGER, FALSE, FALSE});
            map.put(HALFDECIMAL, new String[]{TRUE, FALSE, HALFSCIENCE, DECIMAL, FALSE, FALSE});
            map.put(FALSE, new String[]{FALSE, FALSE, FALSE, FALSE, FALSE, FALSE});
            map.put(TRUE, new String[]{TRUE, FALSE, FALSE, FALSE, FALSE, FALSE});
            map.put(HALFSCIENCE, new String[]{FALSE, FALSE, FALSE, SCIENCE, HALFSIGNEDSCIENCE, FALSE});
            map.put(HALFSIGNEDSCIENCE, new String[]{FALSE, FALSE, FALSE, SCIENCE, FALSE, FALSE});
            map.put(DECIMAL, new String[]{TRUE, FALSE, HALFSCIENCE, DECIMAL, FALSE, FALSE});
            map.put(SCIENCE, new String[]{TRUE, FALSE, FALSE, SCIENCE, FALSE, FALSE});
        }
        public int getValue(char c) {
            if (c == ' ') return 0;
            if (c == '.') return 1;
            if (c == 'e' || c == 'E') return 2;
            if (c >= '0' && c <= '9') return 3;
            if (c == '+' || c == '-') return 4;
            return 5;
        }
        public void get(String s) {
            for (int i = 0; i < s.length(); i++) {
                int index = getValue(s.charAt(i));
                state = map.get(state)[index];
            }
            if (state == TRUE || state == INTEGER || state == DECIMAL || state == SCIENCE || state == HALFDECIMAL) {
                ans = true;
            } else {
                ans = false;
            }
        } 
    }
    public boolean isNumber(String s) {
        Automatation auto = new Automatation();
        auto.get(s);
        return auto.ans;
    }
}

```

### 1569 将子数组重新排序得到同一个二叉查找树的方案数

方法一：先将二叉树构建出来，树的节点中包含了以该节点为树的节点个数。然后 `f(root) = f(left)*f(right)*C(left.num, root.num)`，需要注意其中大数处理比较恶心。

时间复杂度：O(n^2)

空间复杂度：O(n)

```java
import java.math.BigInteger;
class Solution {
    class TreeNode {
        TreeNode left;
        TreeNode right;
        int treeNodeNum;
        int val;
        TreeNode (TreeNode left, TreeNode right, int treeNodeNum, int val) {
            this.left = left;
            this.right = right;
            this.treeNodeNum = treeNodeNum;
            this.val = val;
        }
    }
    int mod = (int)(1e9 + 7);
    public int numOfWays(int[] nums) {
        TreeNode root = buildTree(nums);
        return (int)(numOfWays(root) - 1);
    }
    public TreeNode buildTree(int[] nums) {
        TreeNode root = new TreeNode(null, null, 1, nums[0]);
        for (int i = 1; i < nums.length; i++) {
            TreeNode tmp = root;
            while (true) {
                if (nums[i] > tmp.val) {
                    if (tmp.right == null) {
                        tmp.right = new TreeNode(null, null, 1, nums[i]);
                        tmp.treeNodeNum++;
                        break;
                    }
                    tmp.treeNodeNum++;
                    tmp = tmp.right;
                }
                if (nums[i] < tmp.val) {
                    if (tmp.left == null) {
                        tmp.left = new TreeNode(null, null, 1, nums[i]);
                        tmp.treeNodeNum++;
                        break;
                    }
                    tmp.treeNodeNum++;
                    tmp = tmp.left;
                }
            }
        }
        return root;
    } 
    public int numOfWays(TreeNode root) {
        if (root == null) return 0;
        int leftNum, rightNum, choiceNum;
        BigInteger res = BigInteger.valueOf(1);
        leftNum = (root.left == null)?1: numOfWays(root.left);
        rightNum = (root.right == null)?1: numOfWays(root.right);
        choiceNum = (root.left == null || root.right == null)?1: countNum(root.left.treeNodeNum, root.treeNodeNum-1);
        return res.multiply(BigInteger.valueOf(leftNum)).multiply(BigInteger.valueOf(rightNum)).multiply(BigInteger.valueOf(choiceNum)).mod(BigInteger.valueOf(mod)).intValue(); 
    }
    public int countNum(int m, int n) {
        BigInteger res = BigInteger.valueOf(1);
        for (int i = 0; i < m; i++) {
            res = res.multiply(BigInteger.valueOf(n-i)).divide(BigInteger.valueOf(1+i));
        }
        return res.mod(BigInteger.valueOf(mod)).intValue();
    }
}

```

### 51 N皇后

方法一：回溯

时间复杂度：O(n!)

空间复杂度：O(n)

```java
class Solution {
    List<List<String>> ans;
    public List<List<String>> solveNQueens(int n) {
        ans = new LinkedList<>();
        int[][] square = new int[n][n];
        for (int i = 0; i < n; i++) {
            dfs(square, 0, i, n);
        }
        return ans;
    }
    public void dfs(int[][] square, int x, int y, int n) {
        set(square, x, y, 0, n);
        if (n == 1) {
            List<String> tmp = new LinkedList<>();
            for (int i = 0; i < square.length; i++) {
                StringBuffer sb = new StringBuffer();
                for (int j = 0; j < square.length; j++) {
                    if (square[i][j] > 0) {
                        sb.append('Q');
                    } else {
                        sb.append('.');
                    }
                }
                tmp.add(sb.toString());
            }
            ans.add(tmp);
        }
        int j = 0;
        if (x + 1 < square.length) {
            while (j < square.length) {
                if (square[x+1][j] == 0) dfs(square, x+1, j, n-1);
                j++;
            }
        }
        set(square, x, y, -n, 0);
    }
    public void set(int[][] square, int x, int y, int originValue, int setValue) {
        square[x][y] = setValue;
        for (int i = 0; i < square.length; i++) {
            if (square[x][i] == originValue) square[x][i] = -setValue;
            if (square[i][y] == originValue) square[i][y] = -setValue;
        }
        for (int i = 1; i < square.length; i++) {
            if (x-i >= 0 && x-i < square.length && y-i >= 0 && y-i < square.length) {
                if (square[x-i][y-i] == originValue) square[x-i][y-i] = -setValue;
            }
            if (x+i >= 0 && x+i < square.length && y+i >= 0 && y+i < square.length) {
                if (square[x+i][y+i] == originValue) square[x+i][y+i] = -setValue;
            }
            if (x-i >= 0 && x-i < square.length && y+i >= 0 && y+i < square.length) {
                if (square[x-i][y+i] == originValue) square[x-i][y+i] = -setValue;
            }
            if (x+i >= 0 && x+i < square.length && y-i >= 0 && y-i < square.length) {
                if (square[x+i][y-i] == originValue) square[x+i][y-i] = -setValue;
            }
        }
    }
}

```

### 988 从叶结点开始的最小字符串

方法一：回溯

时间复杂度：O(n^2)

空间复杂度：O(n)


```java
class Solution {
    TreeNode up;
    public String smallestFromLeaf(TreeNode root) {
        up = root;
        StringBuffer ans = new StringBuffer();
        StringBuffer tmp = new StringBuffer();
        backTrack(root, tmp, ans);
        return ans.toString();
    }
    public void backTrack(TreeNode root, StringBuffer tmp, StringBuffer ans) {
        if (root == null) return;
        tmp.append((char)(root.val + 'a'));
        if (root.left == null && root.right == null) {
            if (compare(tmp.reverse(), ans) < 0) {
                ans.delete(0, ans.length());
                ans.append(tmp.toString());
            }
            tmp.reverse();
            tmp.delete(tmp.length()-1, tmp.length());
            return;
        }
        backTrack(root.left, tmp, ans);
        backTrack(root.right, tmp, ans);
        tmp.delete(tmp.length()-1, tmp.length());
    }
    public int compare(StringBuffer a, StringBuffer b) {
        if (a.length() == 0 && b.length() == 0) return 0;
        if (a.length() == 0) return 1;
        if (b.length() == 0) return -1;
        int i = 0;
        while (i < a.length() && i < b.length()) {
            if (a.charAt(i) == b.charAt(i)) {
                i++;
            } else if (a.charAt(i) > b.charAt(i)) {
                return 1;
            } else {
                return -1;
            }
        }
        if (i == a.length() && i == b.length()) return 0;
        if (i == a.length()) return -1;
        return 1;
    }
}

```

### 60 第k个排列

方法一：确定每个位置上的数字应该是多少，利用递归，分解子问题。这里注意需要知道y可以分解成多少个x加上一个数b，其中b不为0。

`k = (y - 1) / x`, `b = (y - 1) % x + 1`;
 
时间复杂度：O(n^2)

空间复杂度：O(n)

```java
class Solution {
    StringBuffer sb = new StringBuffer();
    HashMap<Integer, Integer> map = new HashMap<>();
    int[] factorial;
    public String getPermutation(int n, int k) {
        factorial = new int[n+1];
        factorial[0] = 1;
        for (int i = 1; i <= n; i++) {
            map.put(i, 1);
            factorial[i] = factorial[i-1] * i;
        }
        helper(n, k);
        return sb.toString();
    }

    public void helper(int n, int k) {
        if (n == 0) return;
        int length = map.size();
        int subFact = factorial[n-1];
        int first = (k-1) / subFact + 1;
        int rest = (k-1) % subFact + 1;
        for (int i = 1; i <= length; i++) {
            if (map.get(i) == 1) {
                first--;
                if (first == 0) {
                    sb.append((char)(i+'0'));
                    map.put(i, 0);
                }
            } 
        }
        helper(n-1, rest);
    }
}

```

### 5491. 矩阵对角线元素的和

方法一：遍历

时间复杂度：O(n)

空间复杂度：O(1)

```java
class Solution {
    public int diagonalSum(int[][] mat) {
        int n = mat.length;
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans += mat[i][i];
            ans += mat[i][n-1-i];
        }
        if (n % 2 == 1) ans -= mat[n/2][n/2];
        return ans;
    }
}

```

### 5492 分割字符串的方案数

方法一：排列组合知识，找到相邻部分中间空了多少个0。

时间复杂度：O(n)

空间复杂度：O(1)

```java
import java.math.BigInteger;
class Solution {
    public int numWays(String s) {
        int num1 = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '1') num1++;
        }
        if (num1 % 3 != 0) return 0;
        int mod = (int)(1e9 + 7);
        if (num1 == 0) return BigInteger.valueOf((s.length() - 1)).multiply(BigInteger.valueOf(s.length() - 2)).divide(BigInteger.valueOf(2)).mod(BigInteger.valueOf(mod)).intValue();
        int[] tmp = new int[4];
        int sub = 0;
        int i = 0, k = 0;
        while (i < s.length()) {
            while (sub < num1 / 3) {
                if (s.charAt(i) == '1') {
                    sub++;
                }
                i++;
            }
            tmp[k++] = i;
            while (s.charAt(i) == '0') {
                i++;
            }
            tmp[k++] = i-1;
            if (k == 4) break;
            sub = 0;
        }
        return BigInteger.valueOf(tmp[1] - tmp[0] + 2).multiply(BigInteger.valueOf(tmp[3] - tmp[2] + 2)).mod(BigInteger.valueOf(mod)).intValue();
    }
}

```

### 5493 删除最短的子数组使剩余数组有序

方法一：找到第一个不减区间的起始firstStart 和 firstEnd ，找到最后一个不减区间的起始endStart和endEnd，分四种情况讨论：只保留左边，只保留右边，保留左边一部分，保留右边一部分。

```java
class Solution {
    public int findLengthOfShortestSubarray(int[] arr) {
        int firstStart = 0;
        int firstEnd = 0;
        int i = 0;
        while (i + 1 < arr.length && arr[i+1] >= arr[i]) i++;
        firstEnd = i;
        if (firstEnd == arr.length - 1) return 0;
        while (i + 1 < arr.length && arr[i+1] < arr[i]) i++;
        int endStart = i;
        int endEnd = i;
        while (i + 1 < arr.length) {
            endStart = i;
            while (i+1 < arr.length && arr[i+1] >= arr[i]) i++;
            endEnd = i;
            while (i+1 < arr.length && arr[i+1] < arr[i]) {
                i++;
                endStart = i;
                endEnd = i;
            }
        }
        int ans = Math.min(arr.length-(firstEnd - firstStart + 1), arr.length - (endEnd - endStart + 1));
        i = firstEnd;
        while (i >= 0 && arr[i] > arr[endStart]) {
            i--;
        }
        ans = Math.min(ans, arr.length - (endEnd - endStart + 1) - (i - firstStart + 1));
        i = endStart;
        while (i < arr.length && arr[firstEnd] > arr[i]) {
            i++;
        }
        ans = Math.min(ans, arr.length - (firstEnd - firstStart + 1) - (endEnd - i + 1));
        return ans;
    }
}

```

### 107 二叉树的层序遍历

方法一：队列

时间复杂度：O(n)

空间复杂度：O(n)

```java
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> ans = new LinkedList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int k = 1;
        while (queue.size() != 0) {
            int num = 0;
            List<Integer> tmpList = new LinkedList<>();
            while (k != 0) {
                TreeNode tmp = queue.poll();
                tmpList.add(tmp.val);
                if (tmp.left != null) {
                    queue.offer(tmp.left);
                    num++;
                }
                if (tmp.right != null) {
                    queue.offer(tmp.right);
                    num++;
                }
                k--;
            }
            k = num;
            ans.insert(0, tmpList);
        }
        return ans;
    }
}

```

### 5494 统计所有可行路径

方法一：递归+memo，这里我的解法稍微复杂了些，memo[s][t][f]表示油量为f的前提下，s到t的路线个数。但其实可以简化为memo[s][f]表示在油量为f的前提下，到终点的路线个数。

时间复杂度：O(n^2 * fuel)

空间复杂度：O(n^3)

```java
class Solution {
    int[][] dist;
    int[][][] memo;
    int n;
    int mod = (int)(1e9+7);
    public int countRoutes(int[] locations, int start, int finish, int fuel) {
        n = locations.length;
        dist = new int[n][n];
        memo = new int[n][n][fuel+1];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dist[i][j] = Math.abs(locations[i] - locations[j]);
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k <= fuel; k++) {
                    memo[i][j][k] = -1;
                }
            }
        }
        return helper(start, finish, fuel);
    }
    public int helper(int s, int t, int fuel) {
        if (memo[s][t][fuel] != -1) return memo[s][t][fuel];
        int ret = 0;
        if (s == t) ret++;
        for (int i = 0; i < n; i++) {
            if (fuel >= dist[s][i] && i != s) {
                ret += helper(i, t, fuel-dist[s][i]);
                ret = ret % mod;
            }
        }
        memo[s][t][fuel] = ret;
        return ret;
    }
}

```